<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNES Battleship - Classroom Edition</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #2c0e37;
            --water-color: #3b3b98;
            --grid-line: #5d5dff;
            --hit-color: #ff3e3e;
            --miss-color: #ffffff;
            --ship-color: #8b8b8b;
            --text-color: #e0e0e0;
            --ui-bg: #1a1a2e;
            --ui-border: #dcdcdc;
            --highlight: #ffcc00;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
        }

        /* Scanline Overlay */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
        }

        h1 {
            text-shadow: 4px 4px 0px #000;
            margin-top: 20px;
            font-size: 28px;
            color: var(--highlight);
            text-align: center;
            line-height: 1.5;
        }

        /* TIU Watermark */
        .watermark {
            position: fixed;
            bottom: 15px;
            right: 15px;
            font-size: 30px;
            color: rgba(255, 255, 255, 0.15);
            pointer-events: none;
            z-index: 100;
            font-weight: bold;
            font-family: sans-serif; /* Cleaner look for watermark */
            border: 2px solid rgba(255, 255, 255, 0.15);
            padding: 5px 10px;
            border-radius: 4px;
        }

        /* Connection Panel */
        #connection-panel {
            background: var(--ui-bg);
            border: 4px solid var(--ui-border);
            padding: 30px;
            margin: 20px;
            text-align: center;
            box-shadow: 8px 8px 0px #000;
            max-width: 700px;
            width: 90%;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border: 2px solid #444;
        }

        h3 { color: #00ffff; margin-top: 0; }

        input[type="text"] {
            background: #000;
            color: #0f0;
            border: 2px solid #555;
            padding: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            text-transform: uppercase;
            text-align: center;
            width: 80%;
            align-self: center;
        }

        button {
            background: #a90000;
            color: #fff;
            border: 4px solid #fff;
            padding: 15px 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            cursor: pointer;
            margin-top: 10px;
            box-shadow: 4px 4px 0px #000;
            transition: transform 0.1s;
        }

        button:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0px #000; }
        button:disabled { background: #555; color: #888; border-color: #888; cursor: not-allowed; }

        /* Game Area */
        #game-area {
            display: none;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 40px;
            padding: 20px;
        }

        .board-container { text-align: center; }
        .board-title { margin-bottom: 15px; color: #00ff00; text-shadow: 2px 2px #000; }

        .grid {
            display: grid;
            grid-template-columns: repeat(10, 30px);
            grid-template-rows: repeat(10, 30px);
            background-color: var(--water-color);
            border: 4px solid #fff;
            box-shadow: 6px 6px 0px #000;
        }

        .cell {
            width: 30px;
            height: 30px;
            border: 1px solid var(--grid-line);
            box-sizing: border-box;
            cursor: crosshair;
            position: relative;
        }

        /* Visual states */
        .cell.ship { background-color: var(--ship-color); box-shadow: inset 3px 3px 0 rgba(255,255,255,0.3); }
        .cell.hit { background-color: var(--hit-color); }
        .cell.miss { background-color: var(--water-color); }
        .cell.hit::after { content: 'X'; position: absolute; top: 5px; left: 5px; color: yellow; font-size: 16px; }
        .cell.miss::after { content: 'â€¢'; position: absolute; top: 2px; left: 6px; color: var(--miss-color); font-size: 20px; }

        .cell.preview-valid { background-color: #00ff00; opacity: 0.6; }
        .cell.preview-invalid { background-color: #ff0000; opacity: 0.6; }

        #status-log {
            margin-top: 10px;
            background: #000;
            color: #0f0;
            padding: 15px;
            border: 2px solid #555;
            width: 80%;
            text-align: center;
            font-size: 12px;
            box-shadow: 4px 4px 0 #000;
            line-height: 1.5;
        }

        #rotate-btn { display: none; margin-bottom: 15px; background-color: #0044aa; }
        #enemy-grid.disabled { opacity: 0.6; pointer-events: none; filter: grayscale(100%); }

        /* Overlay */
        #overlay-msg {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 6px solid #fff;
            padding: 50px;
            z-index: 1000;
            text-align: center;
            box-shadow: 15px 15px 0px #000;
        }

        /* Error Text */
        .error-text { color: #ff5555; font-size: 10px; margin-top: 5px; min-height: 15px; }

    </style>
</head>
<body>

    <div class="scanlines"></div>
    <div class="watermark">TIU</div>

    <h1>BATTLESHIP P2P</h1>

    <div id="connection-panel">
        <p>Pick a unique room name (e.g. "Table1")</p>
        
        <div class="input-group">
            <h3>CREATE A GAME</h3>
            <input type="text" id="host-name-input" placeholder="Enter Room Name" maxlength="15">
            <div id="host-error" class="error-text"></div>
            <button id="btn-host">Create Room</button>
        </div>

        <div style="font-size: 10px; color: #666;">--- OR ---</div>

        <div class="input-group">
            <h3>JOIN A GAME</h3>
            <input type="text" id="join-name-input" placeholder="Enter Room Name" maxlength="15">
            <div id="join-error" class="error-text"></div>
            <button id="btn-join">Join Room</button>
        </div>
        
        <p id="conn-status" style="color: #888; margin-top:20px;">System Standby...</p>
    </div>

    <button id="rotate-btn">Rotate Ship (R)</button>
    <div id="status-log">Awaiting Orders...</div>

    <div id="game-area">
        <div class="board-container">
            <div class="board-title">ENEMY RADAR</div>
            <div id="enemy-grid" class="grid disabled"></div>
        </div>
        <div class="board-container">
            <div class="board-title">YOUR FLEET</div>
            <div id="my-grid" class="grid"></div>
        </div>
    </div>

    <div id="overlay-msg">
        <h2 id="overlay-text">GAME OVER</h2>
        <button onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <script>
        // --- Game Configuration ---
        const GRID_SIZE = 10;
        const SHIPS = [5, 4, 3, 3, 2]; 
        const PREFIX = "tiu_battleship_p2p_"; // Hidden prefix to keep rooms unique on public server

        // --- State ---
        let peer = null;
        let conn = null;
        let isHost = false;
        let gameState = 'LOBBY'; 
        let isMyTurn = false;
        
        let myBoard = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        let enemyBoardView = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        
        let shipsToPlace = [...SHIPS];
        let currentShipSize = shipsToPlace[0];
        let isVertical = false;
        let myTotalHitsTaken = 0;
        let enemyTotalHitsTaken = 0;
        const totalShipCells = SHIPS.reduce((a,b)=>a+b, 0);

        // --- Sound Effects (Synthesized) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'select') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'shoot') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'hit') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.4);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now); osc.stop(now + 0.4);
            } else if (type === 'miss') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.linearRampToValueAtTime(300, now + 0.2);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
        }

        // --- Helper: Clean Input ---
        function sanitizeInput(input) {
            return input.trim().toUpperCase().replace(/[^A-Z0-9]/g, '');
        }

        // --- PeerJS Networking ---
        const hostBtn = document.getElementById('btn-host');
        const joinBtn = document.getElementById('btn-join');
        const connStatus = document.getElementById('conn-status');

        hostBtn.addEventListener('click', () => {
            const name = sanitizeInput(document.getElementById('host-name-input').value);
            if(name.length < 3) {
                document.getElementById('host-error').innerText = "Name too short (3+ chars)";
                return;
            }
            playSound('select');
            initHost(name);
        });

        joinBtn.addEventListener('click', () => {
            const name = sanitizeInput(document.getElementById('join-name-input').value);
            if(name.length < 3) {
                document.getElementById('join-error').innerText = "Name too short (3+ chars)";
                return;
            }
            playSound('select');
            initJoin(name);
        });

        function initHost(roomName) {
            hostBtn.disabled = true;
            joinBtn.disabled = true;
            connStatus.innerText = "Creating Room: " + roomName + "...";
            
            // Create Peer with a specific ID based on room name
            const fullId = PREFIX + roomName;
            
            peer = new Peer(fullId);

            peer.on('open', (id) => {
                isHost = true;
                connStatus.innerText = `Room Created: "${roomName}". Waiting for player...`;
                connStatus.style.color = "#ffcc00";
            });

            peer.on('connection', (connection) => {
                setupConnection(connection);
            });

            peer.on('error', (err) => {
                console.log(err);
                if(err.type === 'unavailable-id') {
                    document.getElementById('host-error').innerText = "Room name taken! Try another.";
                    connStatus.innerText = "Error.";
                    hostBtn.disabled = false;
                    joinBtn.disabled = false;
                } else {
                    connStatus.innerText = "Network Error.";
                }
            });
        }

        function initJoin(roomName) {
            hostBtn.disabled = true;
            joinBtn.disabled = true;
            connStatus.innerText = "Searching for Room: " + roomName + "...";

            // When joining, we don't need a specific ID, we just need to connect TO the specific ID
            peer = new Peer(); 

            peer.on('open', (id) => {
                const targetId = PREFIX + roomName;
                conn = peer.connect(targetId);
                
                // If connection fails silently (peer doesn't exist), PeerJS is tricky.
                // We set a timeout to detect failure.
                const timeout = setTimeout(() => {
                    if(!conn.open) {
                        connStatus.innerText = "Room not found or full.";
                        hostBtn.disabled = false;
                        joinBtn.disabled = false;
                    }
                }, 5000);

                conn.on('open', () => {
                    clearTimeout(timeout);
                    setupConnection(conn);
                });
                
                conn.on('error', (err) => {
                    clearTimeout(timeout);
                    connStatus.innerText = "Connection Failed.";
                });
            });
        }

        function setupConnection(connection) {
            conn = connection;
            conn.on('open', () => {
                document.getElementById('connection-panel').style.display = 'none';
                document.getElementById('game-area').style.display = 'flex';
                startPlacementPhase();
            });
            conn.on('data', handleData);
        }

        // --- Game Logic ---
        // (Almost identical to previous, ensuring flow works)

        const myGridEl = document.getElementById('my-grid');
        const enemyGridEl = document.getElementById('enemy-grid');
        const statusLog = document.getElementById('status-log');

        function createGrid(element, isEnemy) {
            element.innerHTML = '';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (!isEnemy) {
                        cell.addEventListener('mouseover', () => handleHover(x, y));
                        cell.addEventListener('click', () => handleClickMyGrid(x, y));
                    } else {
                        cell.addEventListener('click', () => handleClickEnemyGrid(x, y));
                    }
                    element.appendChild(cell);
                }
            }
        }
        createGrid(myGridEl, false);
        createGrid(enemyGridEl, true);

        function startPlacementPhase() {
            gameState = 'PLACING';
            statusLog.innerText = `DEPLOY: Size ${currentShipSize} (Press R to Rotate)`;
            document.getElementById('rotate-btn').style.display = 'block';
        }

        document.getElementById('rotate-btn').addEventListener('click', () => {
            isVertical = !isVertical;
            playSound('select');
        });
        document.addEventListener('keydown', (e) => {
            if(e.key.toLowerCase() === 'r') isVertical = !isVertical;
        });

        function handleHover(x, y) {
            if (gameState !== 'PLACING') return;
            document.querySelectorAll('.preview-valid, .preview-invalid').forEach(el => 
                el.classList.remove('preview-valid', 'preview-invalid'));

            const cells = getShipCells(x, y, currentShipSize, isVertical);
            const isValid = isValidPlacement(cells);
            cells.forEach(pos => {
                if (pos.x < GRID_SIZE && pos.y < GRID_SIZE) {
                    const idx = pos.y * GRID_SIZE + pos.x;
                    myGridEl.children[idx].classList.add(isValid ? 'preview-valid' : 'preview-invalid');
                }
            });
        }

        function handleClickMyGrid(x, y) {
            if (gameState !== 'PLACING') return;
            const cells = getShipCells(x, y, currentShipSize, isVertical);
            if (isValidPlacement(cells)) {
                playSound('select');
                cells.forEach(pos => {
                    myBoard[pos.y][pos.x] = 1; 
                    myGridEl.children[pos.y * GRID_SIZE + pos.x].classList.add('ship');
                });
                shipsToPlace.shift();
                if (shipsToPlace.length > 0) {
                    currentShipSize = shipsToPlace[0];
                    statusLog.innerText = `DEPLOY: Size ${currentShipSize}`;
                } else {
                    gameState = 'WAITING_OPPONENT';
                    statusLog.innerText = "WAITING FOR OPPONENT...";
                    document.getElementById('rotate-btn').style.display = 'none';
                    conn.send({ type: 'READY' });
                }
            } else {
                playSound('miss'); 
            }
        }

        function getShipCells(x, y, length, vertical) {
            const cells = [];
            for (let i = 0; i < length; i++) cells.push({ x: vertical ? x : x + i, y: vertical ? y + i : y });
            return cells;
        }

        function isValidPlacement(cells) {
            return cells.every(pos => 
                pos.x >= 0 && pos.x < GRID_SIZE && pos.y >= 0 && pos.y < GRID_SIZE && myBoard[pos.y][pos.x] === 0
            );
        }

        function handleData(data) {
            if(data.type === 'READY') {
                if(gameState === 'WAITING_OPPONENT') startGame();
                else statusLog.innerText = "Opponent Ready. Finish deploying!";
            }
            if(data.type === 'FIRE') receiveFire(data.x, data.y);
            if(data.type === 'RESULT') processResult(data.x, data.y, data.hit);
        }

        function startGame() {
            gameState = 'PLAYING';
            isMyTurn = isHost; // Host goes first
            updateTurnUI();
        }

        function updateTurnUI() {
            if (isMyTurn) {
                statusLog.innerText = "YOUR TURN: Fire on Enemy Radar";
                statusLog.style.color = "#00ff00";
                enemyGridEl.classList.remove('disabled');
            } else {
                statusLog.innerText = "ENEMY TURN: Hold fast!";
                statusLog.style.color = "#ff3333";
                enemyGridEl.classList.add('disabled');
            }
        }

        function handleClickEnemyGrid(x, y) {
            if (gameState !== 'PLAYING' || !isMyTurn || enemyBoardView[y][x] !== 0) return;
            playSound('shoot');
            enemyBoardView[y][x] = 2; // prevent double click
            isMyTurn = false;
            enemyGridEl.classList.add('disabled');
            statusLog.innerText = "FIRING...";
            conn.send({ type: 'FIRE', x, y });
        }

        function receiveFire(x, y) {
            const isHit = myBoard[y][x] === 1;
            myBoard[y][x] = isHit ? 3 : 2;
            const idx = y * GRID_SIZE + x;
            const cell = myGridEl.children[idx];
            cell.classList.add(isHit ? 'hit' : 'miss');
            
            if(isHit) {
                playSound('hit');
                myTotalHitsTaken++;
                if(myTotalHitsTaken >= totalShipCells) {
                    conn.send({ type: 'RESULT', hit: true, x, y });
                    endGame(false);
                    return;
                }
            } else {
                playSound('miss');
            }
            conn.send({ type: 'RESULT', hit: isHit, x, y });
            isMyTurn = true;
            updateTurnUI();
        }

        function processResult(x, y, hit) {
            enemyBoardView[y][x] = hit ? 3 : 2;
            const idx = y * GRID_SIZE + x;
            const cell = enemyGridEl.children[idx];
            cell.classList.remove('preview-valid');
            cell.classList.add(hit ? 'hit' : 'miss');
            
            if(hit) {
                playSound('hit');
                enemyTotalHitsTaken++;
                statusLog.innerText = "TARGET HIT!";
                if(enemyTotalHitsTaken >= totalShipCells) endGame(true);
            } else {
                playSound('miss');
                statusLog.innerText = "SPLASH. Target missed.";
            }
        }

        function endGame(victory) {
            gameState = 'GAME_OVER';
            document.getElementById('overlay-msg').style.display = 'block';
            const title = document.getElementById('overlay-text');
            if(victory) {
                title.innerText = "VICTORY";
                title.style.color = "#00ff00";
            } else {
                title.innerText = "DEFEAT";
                title.style.color = "#ff0000";
            }
        }
    </script>
</body>
</html>
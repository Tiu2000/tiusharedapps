<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Safe Recorder (Full Suite)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">

    <style>
        :root {
            --primary: #0d6efd;
            --danger: #dc3545;
            --glass: rgba(20, 20, 20, 0.75);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #eee;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden; /* Prevent scrolling for full screen app feel */
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* --- Full Screen Video Area --- */
        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            /* Object-fit contain ensures aspect ratio is kept */
            width: 100%;
            height: 100%;
            object-fit: contain; 
            display: block;
        }
        
        video { display: none; }

        /* --- Floating UI Overlays --- */
        .ui-layer {
            position: absolute;
            z-index: 10;
            transition: opacity 0.3s ease;
        }
        
        /* Top Bar: Settings */
        .top-bar {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 50px;
            border: 1px solid var(--glass-border);
            display: flex;
            gap: 20px;
            align-items: center;
            font-size: 0.9rem;
            max-width: 90%;
            flex-wrap: wrap;
            justify-content: center;
        }

        select, input[type="file"] {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }
        select:hover { background: rgba(255,255,255,0.2); }
        
        .file-upload-btn {
            background: rgba(255,255,255,0.1);
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .file-upload-btn:hover { background: rgba(255,255,255,0.2); }

        /* Bottom Bar: Controls */
        .bottom-bar {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
        }

        button.control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            transition: all 0.2s;
            background: rgba(255,255,255,0.1);
            color: white;
        }
        
        button.control-btn:hover:not(:disabled) { transform: scale(1.1); }
        button.control-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        .btn-record { background-color: var(--danger) !important; box-shadow: 0 0 15px rgba(220, 53, 69, 0.5); }
        .btn-record.recording { animation: pulse 1.5s infinite; border-radius: 30%; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }

        /* Status & Safety Indicators */
        .status-pill {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-family: monospace;
            color: #0f0;
            pointer-events: none;
        }

        #safetyOverlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            display: none;
            pointer-events: none;
            text-align: center;
            z-index: 5;
        }

        /* Watermark */
        .watermark {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-family: Arial, sans-serif;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.3);
            font-size: 3rem;
            pointer-events: none;
            z-index: 5;
            user-select: none;
        }

        /* Checkbox styling */
        .toggle { display: flex; align-items: center; gap: 8px; font-size: 0.85rem; cursor: pointer; }
        .toggle input { accent-color: var(--primary); width: 16px; height: 16px; }

    </style>
</head>
<body>

<div id="app-container">
    <video id="video" playsinline muted crossorigin="anonymous"></video>
    <canvas id="output"></canvas>
    
    <div class="watermark">TIU</div>
    <div id="safetyOverlay">⚠ FACE LOST<br>PRIVACY CURTAIN ACTIVE</div>
    <div class="status-pill" id="status">Initializing AI...</div>

    <div class="ui-layer top-bar">
        <select id="camSelect" title="Camera Source">
            <option value="environment">Back Cam</option>
            <option value="user" selected>Front Cam</option>
        </select>
        
        <label class="file-upload-btn">
            <i class="bi bi-upload"></i> Upload Video
            <input type="file" id="videoUpload" accept="video/*" style="display: none;">
        </label>

        <div style="width: 1px; height: 20px; background: rgba(255,255,255,0.2);"></div>

        <select id="formatSelect" title="Recording Format">
            </select>

        <label class="toggle" title="Anonymize Voice">
            <input type="checkbox" id="voiceToggle"> 
            <span>Robot Voice</span>
        </label>
    </div>

    <div class="ui-layer bottom-bar">
        <button id="btnStart" class="control-btn" title="Start Camera/Play" disabled>
            <i class="bi bi-camera-video-fill"></i>
        </button>
        
        <button id="btnRecord" class="control-btn btn-record" title="Start Recording" disabled>
            <i class="bi bi-record-fill"></i>
        </button>
        
        <button id="btnStop" class="control-btn" title="Stop Recording" disabled>
            <i class="bi bi-stop-fill"></i>
        </button>
    </div>
</div>

<script>
    // --- Configuration ---
    let model = null;
    let stream = null;
    let isFileMode = false;
    let isRecording = false;
    let mediaRecorder;
    let chunks = [];
    
    // Audio Context
    let audioCtx, audioDest, audioSrc;

    // Safety Logic
    let lastFaces = [];
    let lastDetectionTime = 0;
    const MEMORY_TIME = 1000; // 1s memory
    const PANIC_TIME = 4000;  // 4s until total blur

    // DOM Elements
    const video = document.getElementById('video');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const safetyOverlay = document.getElementById('safetyOverlay');
    
    const btnStart = document.getElementById('btnStart');
    const btnRecord = document.getElementById('btnRecord');
    const btnStop = document.getElementById('btnStop');
    const camSelect = document.getElementById('camSelect');
    const formatSelect = document.getElementById('formatSelect');
    const voiceToggle = document.getElementById('voiceToggle');
    const videoUpload = document.getElementById('videoUpload');

    // --- 1. Initialization ---
    
    async function init() {
        populateFormats();
        try {
            status.innerText = "Loading BlazeFace Model...";
            model = await blazeface.load(); 
            status.innerText = "Ready. Select Source.";
            btnStart.disabled = false;
        } catch (e) {
            status.innerText = "Error loading AI: " + e.message;
        }
    }

    function populateFormats() {
        const types = [
            { name: "WebM (Default)", val: "video/webm" },
            { name: "WebM (VP9)", val: "video/webm;codecs=vp9" },
            { name: "MP4 (H.264)", val: "video/mp4" }
        ];

        types.forEach(t => {
            if (MediaRecorder.isTypeSupported(t.val)) {
                const opt = document.createElement('option');
                opt.value = t.val;
                opt.innerText = t.name;
                formatSelect.appendChild(opt);
            }
        });
        
        // If MP4 isn't supported, we fallback to whatever is first
        if (formatSelect.options.length === 0) {
            const opt = document.createElement('option');
            opt.value = ""; 
            opt.innerText = "Browser Default";
            formatSelect.appendChild(opt);
        }
    }

    // --- 2. Input Handling (Camera vs File) ---

    // A. Camera Mode
    btnStart.onclick = async () => {
        if (isFileMode) {
            // If in file mode, this button acts as "Play"
            video.play();
            btnStart.disabled = true; // Can't start again while playing
            return;
        }

        status.innerText = "Starting Camera...";
        const constraints = {
            video: { 
                facingMode: camSelect.value,
                width: { ideal: 1920 },
                height: { ideal: 1080 } 
            },
            audio: true
        };

        try {
            stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            
            video.onloadedmetadata = () => {
                video.play();
                resizeCanvas();
                setupAudio(stream);
                startLoops();
                
                // UI State
                btnStart.disabled = true;
                btnRecord.disabled = false;
                camSelect.disabled = true;
                videoUpload.disabled = true;
                status.innerText = "Live: Privacy Active";
            };
        } catch (err) {
            status.innerText = "Cam Error: " + err.message;
        }
    };

    // B. File Upload Mode
    videoUpload.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        isFileMode = true;
        const url = URL.createObjectURL(file);
        video.srcObject = null;
        video.src = url;
        video.loop = false; // Don't loop uploaded videos
        video.muted = false; // Allow sound for checking

        status.innerText = "Video Loaded. Press Start to Preview.";
        btnStart.innerHTML = '<i class="bi bi-play-fill"></i>';
        btnStart.disabled = false;
        btnRecord.disabled = false;
        camSelect.disabled = true;

        video.onloadedmetadata = () => {
            resizeCanvas();
            // Create audio context from the video element specifically
            if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            audioSrc = audioCtx.createMediaElementSource(video);
            audioDest = audioCtx.createMediaStreamDestination();
            
            // Connect to destination (recording) AND speakers (so user can hear)
            audioSrc.connect(audioDest); 
            audioSrc.connect(audioCtx.destination);
        };
        
        video.onended = () => {
            if(isRecording) stopRecording();
            btnStart.disabled = false;
            status.innerText = "Video Ended.";
        };
        
        // Start loops immediately so we see the first frame
        startLoops();
    };

    function resizeCanvas() {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
    }

    window.addEventListener('resize', () => {
        // Just ensures the CSS handles the display size; 
        // Internal resolution remains native to the video.
    });

    // --- 3. Audio Processing ---
    function setupAudio(inputStream) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        audioSrc = audioCtx.createMediaStreamSource(inputStream);
        audioDest = audioCtx.createMediaStreamDestination();

        if (voiceToggle.checked) {
            // Simple Pitch Shift / Robot effect
            const oscillator = audioCtx.createOscillator();
            oscillator.frequency.value = 50; // Low hum
            const gain = audioCtx.createGain();
            gain.gain.value = 0.5;
            
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1000;

            // Simple graph for privacy
            audioSrc.connect(filter);
            filter.connect(audioDest);
        } else {
            audioSrc.connect(audioDest);
        }
    }

    // --- 4. AI & Drawing Loops ---

    function startLoops() {
        detectFaces();
        drawFrame();
    }

    async function detectFaces() {
        if (!video.paused && !video.ended && video.readyState === 4) {
            const predictions = await model.estimateFaces(video, false);
            if (predictions.length > 0) {
                lastFaces = predictions;
                lastDetectionTime = Date.now();
            }
        }
        requestAnimationFrame(detectFaces);
    }

    function drawFrame() {
        // Draw raw video to canvas first
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const timeSinceFace = Date.now() - lastDetectionTime;
        const hasRecentFace = lastFaces.length > 0 && timeSinceFace < MEMORY_TIME;
        const isPanic = lastFaces.length > 0 && timeSinceFace >= MEMORY_TIME && timeSinceFace < PANIC_TIME;
        const isSafe = lastFaces.length === 0 || timeSinceFace >= PANIC_TIME;

        if (hasRecentFace) {
            safetyOverlay.style.display = 'none';
            // Blur specific faces
            lastFaces.forEach(face => blurRegion(face));
        } else if (isPanic) {
            // Panic mode: Full blur
            safetyOverlay.style.display = 'block';
            safetyOverlay.innerHTML = "⚠ LOST TRACKING<br>FAIL-SAFE ACTIVE";
            applyFullBlur(20);
        } else {
            // Safe / Empty room
            safetyOverlay.style.display = 'none';
            // If strict privacy is required even when empty, uncomment next line:
            // applyFullBlur(5); 
        }

        requestAnimationFrame(drawFrame);
    }

    function blurRegion(face) {
        const start = face.topLeft;
        const end = face.bottomRight;
        const width = end[0] - start[0];
        const height = end[1] - start[1];
        
        // Expand blur area by 20%
        const padding = width * 0.2;
        
        ctx.save();
        ctx.beginPath();
        ctx.rect(start[0] - padding, start[1] - padding, width + (padding*2), height + (padding*2));
        ctx.clip();
        ctx.filter = 'blur(20px)';
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.restore();
    }

    function applyFullBlur(amount) {
        ctx.save();
        ctx.filter = `blur(${amount}px)`;
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        ctx.restore();
    }

    // --- 5. Recording ---

    btnRecord.onclick = () => {
        if (!video.srcObject && !video.src) return;
        
        // If file mode, restart video from beginning for recording
        if(isFileMode && video.ended) {
            video.currentTime = 0;
            video.play();
        }

        // Combine canvas video + processed audio
        const vidTrack = canvas.captureStream(30).getVideoTracks()[0];
        const audTrack = audioDest.stream.getAudioTracks()[0];
        const streamToRecord = new MediaStream([vidTrack, audTrack].filter(t => t));

        const mimeType = formatSelect.value || 'video/webm';
        
        try {
            mediaRecorder = new MediaRecorder(streamToRecord, { mimeType });
        } catch (e) {
            alert("Format not supported. Fallback to default.");
            mediaRecorder = new MediaRecorder(streamToRecord);
        }

        chunks = [];
        mediaRecorder.ondataavailable = e => chunks.push(e.data);
        mediaRecorder.onstop = saveVideo;
        
        mediaRecorder.start();
        isRecording = true;
        
        // UI Updates
        btnRecord.classList.add('recording');
        btnRecord.disabled = true;
        btnStop.disabled = false;
        status.innerText = "REC ● " + (isFileMode ? "(Processing File)" : "(Live)");
    };

    function stopRecording() {
        if(mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            isRecording = false;
            btnRecord.classList.remove('recording');
            btnRecord.disabled = false;
            btnStop.disabled = true;
            status.innerText = "Processing Save...";
        }
    }
    
    btnStop.onclick = stopRecording;

    function saveVideo() {
        const blob = new Blob(chunks, { type: chunks[0].type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        // Determine extension
        const isMp4 = chunks[0].type.includes('mp4');
        a.download = `TIU_SafeRecord_${Date.now()}.${isMp4 ? 'mp4' : 'webm'}`;
        
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            status.innerText = "Saved. Ready.";
        }, 100);
    }

    // Initialize
    init();

</script>
</body>
</html>
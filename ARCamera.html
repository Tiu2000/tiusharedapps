<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Easy AR Blueprint</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #222; }
        
        /* --- AR Overlay UI --- */
        #ar-ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; display: none;
        }
        
        /* Top Info Bar */
        #top-bar {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; color: white; 
            text-shadow: 2px 2px 4px black;
        }
        #instruction { font-size: 18px; font-weight: bold; }
        #live-measure { font-size: 24px; color: #00ff00; margin-top: 5px; }

        /* AR Buttons */
        .ar-btn {
            pointer-events: auto; border: none; border-radius: 30px;
            padding: 12px 24px; font-size: 16px; font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        #undo-btn {
            position: absolute; bottom: 40px; left: 20px;
            background: #ffffff; color: #333;
        }
        #finish-btn {
            position: absolute; bottom: 40px; right: 20px;
            background: #ff4444; color: white;
        }

        /* --- Result Screen --- */
        #result-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; z-index: 100; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        canvas { 
            border: 2px solid #ccc; background: #fff; 
            box-shadow: 0 0 20px rgba(0,0,0,0.1); 
            max-width: 90%; max-height: 60%;
        }
        .result-controls { margin-top: 20px; display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        .save-btn {
            padding: 15px 25px; font-size: 16px; border: none; border-radius: 8px;
            color: white; font-weight: bold; cursor: pointer;
        }
        #save-img { background: #007bff; }
        #save-csv { background: #28a745; }
        #restart { margin-top: 20px; background: none; border: none; color: #666; text-decoration: underline; }
    </style>
</head>
<body>

    <div id="ar-ui">
        <div id="top-bar">
            <div id="instruction">Find the floor...</div>
            <div id="live-measure">0.00 m</div>
        </div>
        <button id="undo-btn" class="ar-btn" onclick="undoPoint()">‚ü≤ Undo</button>
        <button id="finish-btn" class="ar-btn" onclick="finishSession()">Finish Scan</button>
    </div>

    <div id="result-screen">
        <h2 style="color:#333; margin-bottom:10px;">Your Blueprint</h2>
        <canvas id="blueprintCanvas"></canvas>
        <div class="result-controls">
            <button id="save-img" class="save-btn" onclick="downloadImage()">Download Image</button>
            <button id="save-csv" class="save-btn" onclick="downloadCSV()">Download CSV</button>
        </div>
        <button id="restart" onclick="location.reload()">Start New Scan</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let camera, scene, renderer;
        let controller, reticle;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        
        // Scan Data
        let points = []; 
        let lines = [];         // The fixed red lines
        let markers = [];       // The green poles
        let previewLine = null; // The dynamic line following your phone

        init();
        animate();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            // AR Button
            const arUI = document.getElementById('ar-ui');
            const arBtn = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'], 
                domOverlay: { root: arUI } 
            });
            document.body.appendChild(arBtn);

            arBtn.addEventListener('click', () => {
                arUI.style.display = 'block';
            });

            // Controller
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect);
            scene.add(controller);

            // Reticle (Cursor)
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            // Setup Preview Line (Rubber Band)
            const material = new THREE.LineDashedMaterial({
                color: 0xffff00, // Yellow
                dashSize: 0.1,
                gapSize: 0.05,
            });
            const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            previewLine = new THREE.Line(geometry, material);
            previewLine.visible = false;
            scene.add(previewLine);
        }

        function onSelect() {
            if (reticle.visible) {
                const point = new THREE.Vector3();
                point.setFromMatrixPosition(reticle.matrix);
                
                // Add Marker
                const geo = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 32);
                const mat = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
                const marker = new THREE.Mesh(geo, mat);
                marker.position.copy(point);
                marker.position.y += 0.25; 
                scene.add(marker);
                markers.push(marker);

                points.push(point);

                // Add Fixed Wall Line
                if (points.length > 1) {
                    const prev = points[points.length - 2];
                    const lineGeo = new THREE.BufferGeometry().setFromPoints([prev, point]);
                    const lineMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 4 });
                    const line = new THREE.Line(lineGeo, lineMat);
                    scene.add(line);
                    lines.push(line);
                }

                document.getElementById('instruction').innerText = "Tap next corner";
            }
        }

        window.undoPoint = function() {
            if(points.length === 0) return;

            // Remove last point data
            points.pop();

            // Remove last marker visual
            const lastMarker = markers.pop();
            if(lastMarker) scene.remove(lastMarker);

            // Remove last line visual
            if(lines.length > 0) {
                const lastLine = lines.pop();
                scene.remove(lastLine);
            }
            
            // Reset UI
            if(points.length === 0) {
                document.getElementById('instruction').innerText = "Start by tapping a corner";
                document.getElementById('live-measure').innerText = "0.00 m";
            }
        };

        window.finishSession = async function() {
            // Force end session
            try {
                const session = renderer.xr.getSession();
                if (session) await session.end();
            } catch(e) { console.log("Session already ended"); }

            // Switch UI
            document.getElementById('ar-ui').style.display = 'none';
            document.getElementById('result-screen').style.display = 'flex';
            
            setTimeout(drawBlueprint, 100); // Slight delay to ensure DOM is ready
        };

        function drawBlueprint() {
            const canvas = document.getElementById('blueprintCanvas');
            // Make canvas high res
            canvas.width = window.innerWidth * 0.9;
            canvas.height = window.innerHeight * 0.6;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0,0, canvas.width, canvas.height);

            if (points.length < 2) {
                ctx.fillStyle = "black";
                ctx.font = "20px Arial";
                ctx.textAlign = "center";
                ctx.fillText("Not enough corners scanned.", canvas.width/2, canvas.height/2);
                return;
            }

            // 1. Calculate Bounds
            const xs = points.map(p => p.x);
            const zs = points.map(p => p.z);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minZ = Math.min(...zs);
            const maxZ = Math.max(...zs);

            // 2. Setup Scale
            const padding = 50; // pixels
            const roomW = maxX - minX || 1; // prevent divide by 0
            const roomH = maxZ - minZ || 1;
            
            const scaleX = (canvas.width - (padding*2)) / roomW;
            const scaleY = (canvas.height - (padding*2)) / roomH;
            const scale = Math.min(scaleX, scaleY);

            // Helper to convert 3D point to Canvas X,Y
            const toCanvas = (pt) => ({
                x: (pt.x - minX) * scale + padding,
                y: (pt.z - minZ) * scale + padding
            });

            // 3. Draw
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            // Draw Walls
            ctx.beginPath();
            ctx.lineWidth = 6;
            ctx.strokeStyle = "black";
            const start = toCanvas(points[0]);
            ctx.moveTo(start.x, start.y);

            points.forEach(p => {
                const c = toCanvas(p);
                ctx.lineTo(c.x, c.y);
            });
            ctx.stroke();

            // Draw Corners & Text
            points.forEach((p, i) => {
                const curr = toCanvas(p);

                // Red Corner Dot
                ctx.fillStyle = "#ff4444";
                ctx.beginPath();
                ctx.arc(curr.x, curr.y, 8, 0, Math.PI*2);
                ctx.fill();

                // Measurements
                if (i > 0) {
                    const prev = toCanvas(points[i-1]);
                    const dist = p.distanceTo(points[i-1]).toFixed(2) + "m";
                    
                    const midX = (prev.x + curr.x) / 2;
                    const midY = (prev.y + curr.y) / 2;

                    // Text Background
                    ctx.font = "bold 20px Arial";
                    const textWidth = ctx.measureText(dist).width;
                    ctx.fillStyle = "rgba(255,255,255,0.8)";
                    ctx.fillRect(midX - textWidth/2 - 5, midY - 15, textWidth + 10, 30);

                    // Text
                    ctx.fillStyle = "#007bff"; // Bright Blue
                    ctx.textAlign = "center";
                    ctx.fillText(dist, midX, midY + 8);
                }
            });
        }

        window.downloadImage = function() {
            const link = document.createElement('a');
            link.download = 'blueprint.png';
            link.href = document.getElementById('blueprintCanvas').toDataURL();
            link.click();
        }

        window.downloadCSV = function() {
            let csv = "Corner,X,Z,Distance\n";
            points.forEach((p, i) => {
                let d = (i > 0) ? p.distanceTo(points[i-1]).toFixed(2) : 0;
                csv += `${i+1},${p.x.toFixed(2)},${p.z.toFixed(2)},${d}\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'measurements.csv';
            a.click();
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                
                // Logic to update Preview Line (Rubber Band)
                if (points.length > 0 && reticle.visible) {
                    const lastPoint = points[points.length - 1];
                    const cursorPoint = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
                    
                    previewLine.geometry.setFromPoints([lastPoint, cursorPoint]);
                    previewLine.visible = true;

                    // Update Live Text
                    const dist = lastPoint.distanceTo(cursorPoint).toFixed(2);
                    document.getElementById('live-measure').innerText = dist + " m";
                } else {
                    previewLine.visible = false;
                }

                if (hitTestSourceRequested === false) {
                    session.requestReferenceSpace('viewer').then(ref => {
                        session.requestHitTestSource({ space: ref }).then(source => hitTestSource = source);
                    });
                    session.addEventListener('end', () => {
                        hitTestSourceRequested = false; 
                        hitTestSource = null;
                        document.getElementById('ar-ui').style.display = 'none';
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const results = frame.getHitTestResults(hitTestSource);
                    if (results.length > 0) {
                        const hit = results[0];
                        const refSpace = renderer.xr.getReferenceSpace();
                        reticle.visible = true;
                        reticle.matrix.fromArray(hit.getPose(refSpace).transform.matrix);
                    } else {
                        reticle.visible = false;
                    }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
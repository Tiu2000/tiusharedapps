<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro TV Scoreboard (P2P)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    
    <style>
        /* --- ORIGINAL DESIGN STYLES --- */
        :root {
            --bg-color: #000000;
            --text-color: #ffffff;
            --border-color: #222;
        }

        * { box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* --- P2P STATUS INDICATOR (Added for Stability) --- */
        #conn-status {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: #666;
            z-index: 1000;
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(0,0,0,0.5);
            padding: 2px 10px;
            border-radius: 10px;
        }
        .reconnect-btn { background: #444; border: none; color: white; padding: 2px 5px; cursor: pointer; border-radius: 3px; }
        .hidden { display: none; }

        /* --- TOP BAR --- */
        .top-bar {
            flex: 0 0 20vh; /* Top 20% of screen */
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px;
            background: #111;
            border-bottom: 3px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            z-index: 10;
        }

        .timer-container {
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .timer-display {
            font-size: 15vh;
            font-family: 'Courier New', monospace;
            font-weight: 800;
            color: #ff3838; /* LED Red */
            text-shadow: 0 0 15px rgba(255, 56, 56, 0.4);
            cursor: pointer;
            line-height: 1;
        }

        .timer-edit {
            display: none;
            gap: 10px;
        }
        .timer-edit.active { display: flex; }
        
        .timer-input {
            background: #222; border: 1px solid #444; color: white;
            font-size: 3vh; width: 3em; text-align: center; padding: 5px;
        }

        .controls-side {
            display: flex;
            gap: 15px;
        }

        /* --- TEAMS AREA --- */
        #teams-container {
            flex: 1;
            display: flex;
            width: 100%;
            height: 80vh;
        }

        .team-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            border-right: 1px solid var(--border-color);
            position: relative;
            padding-top: 5vh;
            transition: background 0.3s;
        }

        /* Color Picker Wrapper */
        .color-strip {
            width: 100%;
            height: 15px;
            position: absolute;
            top: 0;
            left: 0;
            cursor: pointer;
        }
        .color-input {
            opacity: 0; /* Hidden but clickable */
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Team Name Input */
        .team-name {
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: #eee;
            font-size: 5vw;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            width: 80%;
            margin-bottom: 2vh;
        }
        .team-name:focus { 
            outline: none; 
            border-bottom: 2px solid #555; 
            background: rgba(255,255,255,0.05);
        }

        /* Score */
        .score-display {
            font-size: 30vh;
            font-weight: 800;
            line-height: 1;
            margin: 2vh 0;
            user-select: none;
        }

        /* Controls hidden until hover */
        .score-controls {
            display: flex;
            gap: 20px;
            opacity: 0.1; /* Almost invisible */
            transition: opacity 0.2s;
        }
        /* On mobile/touch, we force opacity so buttons are visible */
        @media (hover: none) { .score-controls { opacity: 0.5; } }
        .team-card:hover .score-controls { opacity: 1; }

        /* --- BUTTONS --- */
        button {
            border: none; padding: 10px 20px; border-radius: 6px;
            font-weight: bold; cursor: pointer; text-transform: uppercase;
            font-family: inherit; transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        .btn-start { background: #2ed573; color: black; font-size: 1.2rem; }
        .btn-stop { background: #ff4757; color: white; font-size: 1.2rem; }
        .btn-std { background: #444; color: white; }

        .btn-score {
            width: 80px; height: 80px; border-radius: 50%;
            font-size: 3rem; display: flex; align-items: center; justify-content: center;
            background: #333; color: white;
        }
        .btn-score:hover { background: white; color: black; }

        .btn-close-team {
            position: absolute; bottom: 15px; right: 15px;
            background: transparent; color: #444; font-size: 1.5rem;
        }
        .btn-close-team:hover { color: red; }

        /* --- TIU WATERMARK --- */
        .app-signature {
            position: fixed; bottom: 5px; left: 10px;
            font-size: 1.5vh; color: #ccc; opacity: 0.2;
            z-index: 1000; font-weight: 300; text-transform: uppercase;
        }
        
        /* --- P2P MODALS (Added) --- */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .modal-content {
            background: #111; padding: 40px; border-radius: 15px; 
            text-align: center; border: 1px solid #444; max-width: 90%;
        }
        .big-btn {
            padding: 20px 40px; font-size: 1.5rem; background: #2196F3;
            border: none; border-radius: 10px; color: white; margin: 10px; cursor: pointer; width: 100%;
        }

    </style>
</head>
<body>

    <div id="conn-status">
        <span id="status-text">OFFLINE</span>
        <button id="reconnectBtn" class="reconnect-btn hidden" onclick="window.location.reload()">ðŸ”„</button>
    </div>

    <div class="top-bar">
        <div class="controls-side">
            <button class="btn-std" onclick="handleInput('addTeam')">+ Team</button>
            <button class="btn-std" onclick="toggleFullScreen()">[ ] Full</button>
            <button class="btn-std" onclick="showQR()">QR</button>
        </div>

        <div class="timer-container">
            <div class="timer-display" id="timer" onclick="toggleTimerEdit()">10:00</div>
            
            <div class="timer-edit" id="timer-edit">
                <input type="number" id="t-min" class="timer-input" value="10">
                <span style="font-size:2rem; padding-top:5px;">:</span>
                <input type="number" id="t-sec" class="timer-input" value="00">
                <button class="btn-std" onclick="saveTimer()">Set</button>
            </div>
        </div>

        <div class="controls-side">
            <button class="btn-start" onclick="handleInput('timerStart')">Start</button>
            <button class="btn-stop" onclick="handleInput('timerStop')">Stop</button>
        </div>
    </div>

    <div id="teams-container">
        </div>

    <div class="app-signature">TIU</div>

    <div id="setup-screen" class="modal">
        <div class="modal-content">
            <h1 style="color:white; margin-bottom: 20px;">PRO SCOREBOARD</h1>
            <button class="big-btn" onclick="initHost()">HOST (Display)</button>
            <div style="border-top:1px solid #444; margin: 20px 0;"></div>
            <p style="color:#888; font-size: 0.9rem;">Scan the Host's QR code to connect as a remote.</p>
        </div>
    </div>

    <div id="qr-modal" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>Scan to Control</h2>
            <div id="qrcode" style="background:white; padding:10px; margin:20px auto; display: inline-block;"></div>
            <br>
            <button class="btn-std" onclick="document.getElementById('qr-modal').style.display='none'">CLOSE</button>
        </div>
    </div>

    <script>
        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'buzzer') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 1.5);
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);
                osc.start(); osc.stop(audioCtx.currentTime + 1.5);
            } else if (type === 'blip') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            }
        }

        // --- GLOBAL STATE ---
        let state = {
            teams: [
                { id: 1, name: "TEAM 1", score: 0, color: "#3498db" },
                { id: 2, name: "TEAM 2", score: 0, color: "#e74c3c" }
            ],
            timeSec: 600,
            isRunning: false
        };
        let nextTeamId = 3;
        let timerInterval = null;

        // --- P2P GLOBALS ---
        let peer, conn;
        let isHost = false;
        let heartbeatInterval;

        // --- RENDER LOGIC ---
        function render() {
            const container = document.getElementById('teams-container');
            const timerDisplay = document.getElementById('timer');

            // 1. Timer
            const m = Math.floor(state.timeSec / 60);
            const s = state.timeSec % 60;
            timerDisplay.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            if(state.isRunning) timerDisplay.style.color = "#4cd137"; // Greenish when running
            else timerDisplay.style.color = "#ff3838"; // Red when stopped

            // 2. Teams
            // To preserve inputs, we check if we need to rebuild or just update
            const currentCards = container.children;
            if (currentCards.length !== state.teams.length) {
                // Full Rebuild if count differs
                container.innerHTML = '';
                state.teams.forEach(team => {
                    const div = document.createElement('div');
                    div.className = 'team-card';
                    div.id = `card-${team.id}`;
                    div.style.background = `linear-gradient(to bottom, ${team.color}22, transparent)`;
                    
                    div.innerHTML = `
                        <div class="color-strip" style="background:${team.color}" id="strip-${team.id}">
                            <input type="color" class="color-input" onchange="handleInput('color', {id:${team.id}, val:this.value})" value="${team.color}">
                        </div>
                        <input type="text" class="team-name" id="name-${team.id}" value="${team.name}" onchange="handleInput('name', {id:${team.id}, val:this.value})">
                        <div class="score-display" id="score-${team.id}">${team.score}</div>
                        <div class="score-controls">
                            <button class="btn-score" onclick="handleInput('score', {id:${team.id}, val:-1})">-</button>
                            <button class="btn-score" onclick="handleInput('score', {id:${team.id}, val:1})">+</button>
                        </div>
                        <button class="btn-close-team" onclick="handleInput('removeTeam', {id:${team.id}})">&times;</button>
                    `;
                    container.appendChild(div);
                });
            } else {
                // Smart Update
                state.teams.forEach((team, index) => {
                    const card = currentCards[index];
                    // Update Score
                    const scoreEl = card.querySelector('.score-display');
                    if(scoreEl.innerText != team.score) scoreEl.innerText = team.score;
                    
                    // Update Name (only if not focused)
                    const nameEl = card.querySelector('.team-name');
                    if(document.activeElement !== nameEl) nameEl.value = team.name;

                    // Update Color
                    const stripEl = card.querySelector('.color-strip');
                    if(stripEl.style.background != team.color) {
                        stripEl.style.background = team.color;
                        card.style.background = `linear-gradient(to bottom, ${team.color}22, transparent)`;
                    }
                });
            }

            // Sync timer state locally
            if (state.isRunning && !timerInterval) {
                timerInterval = setInterval(tick, 1000);
            } else if (!state.isRunning && timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // Send to peers if Host
            if(isHost && conn) sendState();
        }

        // --- INPUT HANDLER ---
        function handleInput(type, data={}) {
            // Modify Local State
            if (type === 'score') {
                const t = state.teams.find(x => x.id === data.id);
                if(t) { t.score = Math.max(0, t.score + data.val); playSound('blip'); }
            }
            else if (type === 'name') {
                const t = state.teams.find(x => x.id === data.id);
                if(t) t.name = data.val;
            }
            else if (type === 'color') {
                const t = state.teams.find(x => x.id === data.id);
                if(t) t.color = data.val;
            }
            else if (type === 'addTeam') {
                const colors = ['#3498db', '#e74c3c', '#f1c40f', '#9b59b6'];
                state.teams.push({ 
                    id: nextTeamId++, 
                    name: `TEAM ${state.teams.length+1}`, 
                    score: 0, 
                    color: colors[state.teams.length % colors.length] 
                });
            }
            else if (type === 'removeTeam') {
                state.teams = state.teams.filter(t => t.id !== data.id);
            }
            else if (type === 'timerStart') {
                if(state.timeSec > 0) state.isRunning = true;
            }
            else if (type === 'timerStop') {
                state.isRunning = false;
            }
            else if (type === 'timerSet') {
                state.timeSec = data.val;
            }
            else if (type === 'sync') {
                state = data; // Full replace from Host
            }

            render();

            // If Client, send command to Host
            if (!isHost && conn) {
                conn.send({ type: 'cmd', act: type, data: data });
            }
        }

        function tick() {
            if (state.timeSec > 0) {
                state.timeSec--;
                render();
            } else {
                state.isRunning = false;
                render();
                playSound('buzzer');
                document.body.style.background = "#550000"; 
                setTimeout(() => document.body.style.background = "var(--bg-color)", 1000);
            }
        }

        // --- LOCAL UI HELPERS ---
        function toggleTimerEdit() {
            if(state.isRunning) return;
            document.getElementById('timer').style.display = 'none';
            document.getElementById('timer-edit').classList.add('active');
        }

        function saveTimer() {
            const m = parseInt(document.getElementById('t-min').value) || 0;
            const s = parseInt(document.getElementById('t-sec').value) || 0;
            handleInput('timerSet', { val: (m * 60) + s });
            document.getElementById('timer-edit').classList.remove('active');
            document.getElementById('timer').style.display = 'block';
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        }
        
        function showQR() {
            if(isHost) document.getElementById('qr-modal').style.display = 'flex';
        }

        function setStatus(msg) {
            document.getElementById('status-text').innerText = msg;
        }

        // --- P2P LOGIC ---
        function initHost() {
            isHost = true;
            document.getElementById('setup-screen').style.display = 'none';
            setStatus("Waiting for Remote...");

            peer = new Peer();
            peer.on('open', (id) => {
                const url = window.location.href.split('?')[0] + '?connect=' + id;
                new QRCode(document.getElementById("qrcode"), { text: url, width: 200, height: 200 });
                document.getElementById('qr-modal').style.display = 'flex';
            });

            peer.on('connection', (c) => {
                conn = c;
                setStatus("Remote Connected");
                document.getElementById('qr-modal').style.display = 'none';

                conn.on('data', (d) => {
                    if(d.type === 'heartbeat') return;
                    if(d.type === 'cmd') {
                        // Host receives command, executes it locally (which updates state), then render() sends state back
                        handleInput(d.act, d.data); 
                    }
                });
                sendState();
            });
            render();
        }

        function initClient(id) {
            isHost = false;
            document.getElementById('setup-screen').style.display = 'none';
            connectToHost(id);
        }

        function connectToHost(id) {
            setStatus("Connecting...");
            if(peer) peer.destroy();
            peer = new Peer();

            peer.on('open', () => {
                conn = peer.connect(id);
                conn.on('open', () => {
                    setStatus("Connected");
                    document.getElementById('reconnectBtn').classList.add('hidden');

                    if(heartbeatInterval) clearInterval(heartbeatInterval);
                    heartbeatInterval = setInterval(() => {
                        if(conn && conn.open) conn.send({type: 'heartbeat'});
                    }, 2000);
                });

                conn.on('data', (d) => {
                    if(d.type === 'state') {
                        // Client trusts Host state blindly
                        state = d.data;
                        render();
                    }
                });

                conn.on('close', () => {
                    setStatus("Disconnected");
                    document.getElementById('reconnectBtn').classList.remove('hidden');
                    setTimeout(() => connectToHost(id), 1000);
                });
            });
        }

        function sendState() {
            if(conn && conn.open) conn.send({type: 'state', data: state});
        }

        // --- INIT ---
        const params = new URLSearchParams(window.location.search);
        if(params.get('connect')) initClient(params.get('connect'));
        else render(); // Default view

    </script>
</body>
</html>
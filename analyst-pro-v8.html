<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>TIU Analyst Suite PRO - v8.6 (Zoom & Pan)</title>
    <script src="https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1"></script>
    <style>
        :root {
            --primary-color: #1a1a1a;
            --accent-color: #fdd835;
            --text-color: #ffffff;
            --panel-bg: #2d2d2d;
            --btn-bg: #444;
            --danger-color: #d32f2f;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--primary-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding-bottom: 50px;
            overscroll-behavior: none;
        }

        /* --- HEADER --- */
        header {
            width: 100%;
            padding: 10px 0;
            background-color: var(--panel-bg);
            text-align: center;
            border-bottom: 2px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        h1 { margin: 0; font-size: 1.2rem; letter-spacing: 1px; white-space: nowrap; }
        .badge-4k { 
            background: #000; color: var(--accent-color); border: 1px solid var(--accent-color);
            padding: 2px 6px; font-size: 0.7rem; font-weight: 900; border-radius: 3px;
        }

        google-cast-launcher {
            width: 24px; height: 24px; cursor: pointer;
            --connected-color: var(--accent-color); --disconnected-color: #888;
        }
        google-cast-launcher:hover { --disconnected-color: white; }

        /* --- STAGE --- */
        #stage-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
            background: #000;
            padding: 10px 0;
            overflow: hidden; /* Important for zoom cropping */
        }

        #stage-container {
            position: relative;
            width: 95%; 
            max-width: 1600px; 
            aspect-ratio: 16 / 9; 
            background: #000;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 2px solid #444;
            outline: none; 
            transform-origin: 0 0; /* Default pivot */
            /* Transition for smooth zoom reset, but we handle pan manually for speed */
            transition: transform 0.1s ease-out; 
        }

        /* The "Zoom Container" wraps content that scales */
        .zoom-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform-origin: 0 0;
            pointer-events: none; /* Let clicks pass unless handling pan */
        }

        #player { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: auto;}

        #focus-catcher {
            position: absolute; top: 0; left: 0; width: 100%; height: 85%;
            z-index: 5; cursor: pointer; background: rgba(0,0,0,0);
        }

        #drawing-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; cursor: crosshair;
            pointer-events: none; touch-action: none;
            transition: opacity 0.5s ease; 
        }
        
        .canvas-fade-out { opacity: 0; }

        .watermark {
            position: absolute; bottom: 2%; right: 2%;
            font-size: clamp(1.5rem, 5vw, 4rem);
            font-weight: 900;
            color: rgba(255, 255, 255, 0.15);
            z-index: 6; pointer-events: none; user-select: none;
            font-family: 'Arial Black', sans-serif;
        }

        /* --- CONTROLS PANEL --- */
        .controls-panel {
            width: 95%; max-width: 1600px;
            background-color: var(--panel-bg);
            padding: 15px; border-radius: 8px; margin-top: 15px;
            display: grid; grid-template-columns: 1fr 1.5fr 1fr; 
            gap: 15px; box-sizing: border-box;
        }

        .control-group {
            display: flex; flex-direction: column; gap: 8px;
            border-right: 1px solid #444; padding-right: 15px;
        }
        .control-group:last-child { border-right: none; padding-left: 10px; padding-right: 0;}

        .group-label { font-size: 0.75rem; text-transform: uppercase; color: #888; font-weight: bold; margin-bottom: 5px; }

        button {
            background-color: var(--btn-bg); color: white;
            border: 1px solid #555; padding: 8px 12px;
            border-radius: 4px; cursor: pointer;
            font-weight: 600; font-size: 0.85rem;
            transition: all 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 5px;
        }
        button:hover { background-color: #555; }
        button:active { transform: translateY(1px); }
        
        button.active { background-color: var(--accent-color); color: black; border-color: var(--accent-color); }
        button.danger { background-color: var(--danger-color); border-color: #b71c1c;}
        button.secondary { background-color: transparent; border: 1px solid #666; }
        button.action { background-color: #2e7d32; border-color: #1b5e20; }

        input[type="text"] {
            padding: 8px; border-radius: 4px; border: 1px solid #555;
            background: #222; color: white; flex-grow: 1;
        }
        
        input[type="range"] { accent-color: var(--accent-color); }

        .tools-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 5px;}
        
        .color-btn {
            width: 24px; height: 24px; border-radius: 50%; border: 2px solid #fff;
            cursor: pointer; flex-shrink: 0; transition: transform 0.2s;
        }
        .color-btn.selected { transform: scale(1.3); box-shadow: 0 0 8px rgba(255,255,255,0.5); }

        #mode-indicator {
            padding: 5px 12px; border-radius: 4px; font-weight: bold;
            font-size: 0.9rem; background: #444;
        }
        .mode-viewing { background: #2196f3; }
        .mode-drawing { background: var(--accent-color); color: black; }
        .mode-zooming { background: #9c27b0; color: white; }

        .annotation-list {
            list-style: none; padding: 0; margin: 0;
            display: flex; flex-direction: column; gap: 6px;
            max-height: 200px; overflow-y: auto;
        }
        .annotation-item {
            background: #333; border: 1px solid #444; padding: 8px;
            border-radius: 4px; display: flex; justify-content: space-between;
            align-items: center; cursor: pointer; transition: background 0.2s;
        }
        .annotation-item:hover { background: #444; border-color: #666; }
        .annotation-time {
            font-family: monospace; background: #222; padding: 2px 6px;
            border-radius: 3px; margin-right: 8px; color: var(--accent-color); font-size: 0.8rem;
        }
        
        #save-status { font-size: 0.75rem; color: #888; margin-top: 5px; text-align: right; font-style: italic; }

        @media (max-width: 900px) {
            .controls-panel { grid-template-columns: 1fr; gap: 20px; }
            .control-group { border-right: none; border-bottom: 1px solid #444; padding-bottom: 15px; padding-left: 0; padding-right: 0;}
            .control-group:last-child { border-bottom: none; }
        }
    </style>
</head>
<body>

<header>
    <h1>TIU ANALYST PRO</h1>
    <span class="badge-4k">4K ENGINE</span>
    <google-cast-launcher></google-cast-launcher>
    
    <div id="mode-indicator" class="mode-viewing">VIEWING</div>
    <button onclick="toggleFullscreen()" class="secondary" style="margin-left:auto; font-size: 0.8rem;">
        Fullscreen (F)
    </button>
    <button onclick="toggleShortcuts()" class="secondary" style="font-size: 0.8rem;">?</button>
</header>

<div id="stage-wrapper">
    <div id="stage-container" tabindex="0"> 
        <div id="zoom-layer" class="zoom-layer">
            <div id="player"></div>
            <div id="focus-catcher" onclick="onShieldClick()"></div>
            <canvas id="drawing-canvas"></canvas>
            <div class="watermark">TIU</div>
        </div>
    </div>
</div>

<div class="controls-panel">
    
    <div class="control-group">
        <div class="group-label">Source & Playback</div>
        
        <div class="tools-row">
            <input type="text" id="yt-input" placeholder="YouTube Link...">
            <button onclick="loadVideo()">Load</button>
        </div>

        <div class="tools-row" style="justify-content: space-between;">
             <button onclick="skipTime(-5)" title="Key: J" style="flex:1;">&#9194; -5s</button>
             <button onclick="skipTime(5)" title="Key: L" style="flex:1;">+5s &#9193;</button>
        </div>

        <div class="tools-row" style="justify-content: space-between;">
            <button onclick="frameStep(-1)" title="Key: < or ArrowLeft">&#9664; Frame</button>
            <button onclick="togglePlay()" style="flex-grow: 2;">Play / Pause</button>
            <button onclick="frameStep(1)" title="Key: > or ArrowRight">Frame &#9654;</button>
        </div>

        <div class="tools-row">
            <span style="font-size:0.8rem; color:#aaa;">Speed:</span>
            <button onclick="setSpeed(0.25)" class="secondary">0.25x</button>
            <button onclick="setSpeed(0.5)" class="secondary">0.5x</button>
            <button onclick="setSpeed(1.0)" class="secondary">1.0x</button>
        </div>
        
        <div style="margin-top:auto; background: #222; padding: 10px; border-radius: 5px; border: 1px solid #333;">
             <div class="group-label">Annotation Persistence</div>
             <div style="display: flex; align-items: center; justify-content: space-between; font-size: 0.85rem;">
                 <label for="auto-clear-range">Auto-Clear Delay:</label>
                 <span id="auto-clear-display" style="color: var(--accent-color);">Manual</span>
             </div>
             <input type="range" id="auto-clear-range" min="0" max="5" step="0.5" value="0" style="width: 100%; margin-top: 5px;" oninput="updateAutoClearLabel(this.value)">
        </div>
    </div>

    <div class="control-group">
        <div class="group-label">Telestrator Tools</div>
        
        <div class="tools-row">
            <button id="draw-mode-btn" onclick="toggleDrawMode()" style="flex-grow:2;">Enable Drawing</button>
            <button id="zoom-mode-btn" onclick="toggleZoomMode()" style="flex-grow:1;" title="Enable Zoom/Pan (Scroll to zoom, Drag to pan)">&#128269; Zoom</button>
        </div>
        <div class="tools-row">
             <button onclick="undoLast()"><span class="icon">&#8630;</span> Undo</button>
             <button class="danger" onclick="clearCanvas()" title="Key: C or Backspace"><span class="icon">&#10005;</span> Clear</button>
        </div>

        <div class="tools-row" style="background:#222; padding:5px; border-radius:4px; justify-content: space-between;">
            <div style="display:flex; gap:5px;">
                <button class="tool-btn active" id="tool-pen" onclick="setTool('pen')">Pen</button>
                <button class="tool-btn" id="tool-highlighter" onclick="setTool('highlighter')">Highlighter</button>
            </div>
            <div style="display:flex; gap:5px;">
                <button class="shape-btn active" id="shape-free" onclick="setShape('free')">&#x2710;</button>
                <button class="shape-btn" id="shape-arrow" onclick="setShape('arrow')">&#8594;</button>
                <button class="shape-btn" id="shape-circle" onclick="setShape('circle')">&#9711;</button>
            </div>
        </div>

        <div class="tools-row" style="margin-top: 10px;">
            <div class="color-btn selected" id="color-btn-0" style="background: #fdd835;" onclick="setColor('#fdd835', this)"></div>
            <div class="color-btn" id="color-btn-1" style="background: #ff0000;" onclick="setColor('#ff0000', this)"></div>
            <div class="color-btn" id="color-btn-2" style="background: #ffffff;" onclick="setColor('#ffffff', this)"></div>
            <div class="color-btn" id="color-btn-3" style="background: #000000;" onclick="setColor('#000000', this)"></div>
            <div class="color-btn" id="color-btn-4" style="background: #00e5ff;" onclick="setColor('#00e5ff', this)"></div> 
            
            <div style="margin-left: auto; display: flex; align-items: center; gap: 8px;">
                <span style="font-size: 0.8rem; color:#aaa;">Size</span>
                <input type="range" id="pen-size" min="2" max="20" value="4" style="width: 80px;" oninput="saveToolState()">
            </div>
        </div>
        
        <button onclick="saveDrawing()" class="secondary" style="margin-top: 10px; width: 100%;">
            <span class="icon">&#128190;</span> Download Screenshot (High-Res)
        </button>
    </div>

    <div class="control-group">
        <div class="group-label">Saved Plays & System</div>
        <button onclick="saveSnapshot()" style="background-color: #2196f3; border-color: #1976d2; margin-bottom: 10px;">
            <span class="icon">&#43;</span> Save Current Frame
        </button>
        
        <ul id="annotation-list" class="annotation-list">
            <li class="annotation-item" style="justify-content:center; color:#666; cursor:default;">No saved plays.</li>
        </ul>

        <div style="margin-top: auto; padding-top: 10px; border-top: 1px solid #444;">
             <div class="tools-row">
                 <button onclick="exportPlaybook()" class="action" style="flex:1;">Export</button>
                 <button onclick="document.getElementById('import-file').click()" class="action" style="flex:1;">Import</button>
                 <input type="file" id="import-file" accept=".json" style="display:none" onchange="importPlaybook(this)">
             </div>
             
             <div class="tools-row" style="margin-top: 10px;">
                <button onclick="hardReset()" class="danger" style="width:100%; font-size: 0.7rem;">
                    &#9888; FACTORY RESET APP
                </button>
             </div>
             <div id="save-status">Loading session...</div>
        </div>
    </div>
</div>

<script>
    // --- STATE VARIABLES ---
    let player;
    let isDrawingMode = false;
    let isZoomMode = false;
    let isDrawing = false;
    let isPanning = false; // Zoom pan state
    
    // Zoom/Pan Vars
    let scale = 1;
    let panX = 0; 
    let panY = 0;
    let startPanX = 0;
    let startPanY = 0;

    let annotations = []; 
    let currentTool = 'pen'; 
    let currentShape = 'free'; 
    let currentColor = '#fdd835';
    let autoClearDuration = 0; 
    let clearTimer = null;
    let restoreTime = null; 
    let isSessionLoaded = false;
    let dpr = 1; 
    
    // History
    let drawHistory = [];
    let historyStep = -1;

    // DOM Elements
    const canvas = document.getElementById('drawing-canvas');
    const ctx = canvas.getContext('2d');
    const stage = document.getElementById('stage-container');
    const zoomLayer = document.getElementById('zoom-layer');
    const drawBtn = document.getElementById('draw-mode-btn');
    const zoomBtn = document.getElementById('zoom-mode-btn');
    const modeIndicator = document.getElementById('mode-indicator');
    const shield = document.getElementById('focus-catcher'); 
    const saveStatusEl = document.getElementById('save-status');
    const autoClearDisplay = document.getElementById('auto-clear-display');

    // --- ZOOM LOGIC ---
    function updateTransform() {
        // Clamping logic to keep view somewhat bounded
        // Limit Zoom
        if (scale < 1) scale = 1;
        if (scale > 5) scale = 5;

        // Apply to CSS Layer
        zoomLayer.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
    }

    function toggleZoomMode() {
        isZoomMode = !isZoomMode;
        if(isZoomMode) {
            // Disable drawing mode if active to avoid conflict
            if(isDrawingMode) toggleDrawMode(); 
            
            zoomBtn.classList.add('active');
            stage.style.cursor = 'grab';
            modeIndicator.innerText = "ZOOM / PAN";
            modeIndicator.className = "mode-zooming";
            
            // Allow pointer events on stage for panning
            shield.style.pointerEvents = 'auto'; 
            canvas.style.pointerEvents = 'none';
        } else {
            zoomBtn.classList.remove('active');
            stage.style.cursor = 'default';
            // Reset to Viewing or Drawing state
            if (isDrawingMode) {
                toggleDrawMode(); // Re-enable drawing visuals
            } else {
                modeIndicator.innerText = "VIEWING";
                modeIndicator.className = "mode-viewing";
            }
            
            // Reset View
            scale = 1; panX = 0; panY = 0;
            updateTransform();
        }
    }

    // Scroll Wheel Zoom
    stage.addEventListener('wheel', (e) => {
        if (!isZoomMode) return;
        e.preventDefault();
        const delta = e.deltaY * -0.001;
        const newScale = Math.min(Math.max(1, scale + delta), 5);
        
        // Simple zoom-towards-center logic
        // (Improving this to zoom-to-mouse would require more complex offset calcs)
        scale = newScale;
        updateTransform();
    });

    // Panning Logic
    stage.addEventListener('mousedown', (e) => {
        if (!isZoomMode) return;
        isPanning = true;
        stage.style.cursor = 'grabbing';
        startPanX = e.clientX - panX;
        startPanY = e.clientY - panY;
    });

    window.addEventListener('mousemove', (e) => {
        if (!isPanning) return;
        e.preventDefault();
        panX = e.clientX - startPanX;
        panY = e.clientY - startPanY;
        updateTransform();
    });

    window.addEventListener('mouseup', () => {
        if(isPanning) {
            isPanning = false;
            stage.style.cursor = 'grab';
        }
    });


    // --- INITIALIZATION ---
    function resizeCanvas() {
        let savedData = null;
        if (canvas.width > 0 && canvas.height > 0) {
            savedData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        dpr = Math.max(window.devicePixelRatio || 1, 2); 

        canvas.width = stage.clientWidth * dpr;
        canvas.height = stage.clientHeight * dpr;

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        if (savedData) {
            ctx.putImageData(savedData, 0, 0);
        } else if (localStorage.getItem('tiu_active_canvas')) {
            const img = new Image();
            img.onload = () => {
                ctx.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.drawImage(img, 0, 0);
                ctx.scale(dpr, dpr);
            };
            img.src = localStorage.getItem('tiu_active_canvas');
        }

        ctx.scale(dpr, dpr);
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
    }
    window.addEventListener('resize', resizeCanvas);
    
    // --- PERSISTENCE: LOAD ---
    window.onload = function() {
        resizeCanvas();
        const savedData = localStorage.getItem('tiu_analyst_data');
        if (savedData) {
            try {
                const data = JSON.parse(savedData);
                window.lastVideoId = data.videoId;
                if(data.plays) annotations = data.plays;
                if(data.lastTime) restoreTime = data.lastTime;
                
                if(data.toolState) {
                    const ts = data.toolState;
                    setTool(ts.tool || 'pen');
                    setShape(ts.shape || 'free');
                    if(ts.color) {
                         const matchBtn = Array.from(document.querySelectorAll('.color-btn')).find(b => 
                            b.onclick.toString().includes(ts.color)
                         );
                         if(matchBtn) setColor(ts.color, matchBtn);
                    }
                    if(ts.size) document.getElementById('pen-size').value = ts.size;
                }

                renderAnnotations();
                saveStatusEl.innerText = "Session Restored.";
                if(data.videoId) document.getElementById('yt-input').value = "https://youtu.be/" + data.videoId;
            } catch(e) { console.error("Data Load Error", e); }
        }
        isSessionLoaded = true; 
    };

    // --- PERSISTENCE: SAVE ---
    function performAutoSave() {
        if (!isSessionLoaded) return; 

        const videoData = player && player.getVideoData ? player.getVideoData() : null;
        
        const toolState = {
            tool: currentTool,
            shape: currentShape,
            color: currentColor,
            size: document.getElementById('pen-size').value
        };

        const data = {
            videoId: videoData ? videoData.video_id : window.lastVideoId,
            plays: annotations,
            lastTime: player && player.getCurrentTime ? player.getCurrentTime() : 0,
            toolState: toolState,
            timestamp: Date.now()
        };
        localStorage.setItem('tiu_analyst_data', JSON.stringify(data));
        
        // Save Active Canvas (High Res Data URL)
        localStorage.setItem('tiu_active_canvas', canvas.toDataURL());
        
        saveStatusEl.innerText = "Saved " + new Date().toLocaleTimeString();
    }
    
    setInterval(performAutoSave, 5000);
    window.addEventListener('beforeunload', () => { performAutoSave(); });

    function hardReset() {
        if(confirm("Are you sure? This will delete all saved plays, settings, and drawings.")) {
            localStorage.removeItem('tiu_analyst_data');
            localStorage.removeItem('tiu_active_canvas');
            location.reload();
        }
    }
    
    function saveToolState() { performAutoSave(); }

    // --- YOUTUBE API ---
    var tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    function onYouTubeIframeAPIReady() {
        const vidToLoad = window.lastVideoId || 'tVoqA-LKGb4';
        player = new YT.Player('player', {
            height: '100%', width: '100%', videoId: vidToLoad, 
            playerVars: { 
                'playsinline': 1, 
                'rel': 0, 
                'controls': 1,
                'vq': 'hd2160',
                'suggestedQuality': 'highres' 
            },
            events: { 
                'onReady': onPlayerReady, 
                'onStateChange': onPlayerStateChange,
                'onError': (e) => console.log("YT Error", e)
            }
        });
    }
    
    function onPlayerReady(event) { 
        event.target.setPlaybackQuality('highres');
        resizeCanvas();
        if (restoreTime && restoreTime > 0) {
            player.seekTo(restoreTime);
        }
    }
    
    function updateAutoClearLabel(val) {
        autoClearDuration = parseFloat(val);
        if(val == 0) autoClearDisplay.innerText = "Manual";
        else autoClearDisplay.innerText = val + " sec";
    }

    function onPlayerStateChange(event) {
        if (event.data === 1) { // Playing
            if (autoClearDuration > 0) {
                if(clearTimer) clearTimeout(clearTimer);
                clearTimer = setTimeout(() => {
                    canvas.classList.add('canvas-fade-out'); 
                    setTimeout(() => {
                        clearCanvas(true); 
                        canvas.classList.remove('canvas-fade-out'); 
                    }, 500); 
                }, autoClearDuration * 1000);
            }
        } else {
            if(clearTimer) clearTimeout(clearTimer);
            canvas.classList.remove('canvas-fade-out');
            performAutoSave();
        }
    }

    function loadVideo(optionalId) {
        let id = optionalId;
        if (!id) {
            const input = document.getElementById('yt-input').value;
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/;
            const match = input.match(regExp);
            id = (match && match[2].length === 11) ? match[2] : null;
        }
        
        if (player && id) {
            const currentVid = window.lastVideoId;
            const isNewVideo = (id !== currentVid);

            player.loadVideoById(id);
            player.setPlaybackQuality('highres');
            
            if(!optionalId) { 
                if (isNewVideo) {
                    annotations = []; 
                    restoreTime = 0; 
                    window.lastVideoId = id;
                    clearCanvas();
                }
                renderAnnotations();
                performAutoSave();
            }
        } else { alert("Invalid YouTube ID."); }
    }

    // --- CONTROLS ---
    function onShieldClick() { stage.focus(); togglePlay(); }
    
    function togglePlay() { 
        if(!player) return;
        player.getPlayerState() === 1 ? player.pauseVideo() : player.playVideo(); 
    }
    
    function setSpeed(rate) { 
        if(player) player.setPlaybackRate(rate); 
    }
    
    function skipTime(seconds) {
        if(!player) return;
        const currentTime = player.getCurrentTime();
        player.seekTo(currentTime + seconds, true);
        performAutoSave();
    }
    
    function frameStep(dir) {
        if(!player) return;
        player.pauseVideo();
        player.seekTo(player.getCurrentTime() + (dir * 0.04), true);
    }
    
    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            stage.requestFullscreen().catch(err => console.log(err));
        } else {
            document.exitFullscreen();
        }
    }
    document.addEventListener('fullscreenchange', () => {
        setTimeout(resizeCanvas, 200); 
        if (document.fullscreenElement) setTimeout(() => stage.focus(), 100);
    });
    
    function toggleShortcuts() {
        alert("Space/K: Play/Pause\nJ/L: -5s/+5s\nLeft/Right: Frame\nC: Clear");
    }

    // --- ANNOTATIONS SYSTEM ---
    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s < 10 ? '0' : ''}${s}`;
    }

    function saveSnapshot() {
        if (!player) return;
        const name = prompt("Name this play:", "Play " + (annotations.length + 1));
        if (name === null) return; 

        annotations.push({
            id: Date.now(),
            time: player.getCurrentTime(),
            image: canvas.toDataURL(), 
            name: name
        });
        annotations.sort((a, b) => a.time - b.time);
        renderAnnotations();
        performAutoSave();
    }

    function loadAnnotation(id) {
        const note = annotations.find(a => a.id === id);
        if (!note) return;
        player.seekTo(note.time, true);
        player.pauseVideo();
        const img = new Image();
        img.onload = function() {
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            ctx.scale(dpr, dpr);
            saveHistory();
            performAutoSave(); 
        };
        img.src = note.image;
    }

    function deleteAnnotation(id, event) {
        event.stopPropagation();
        if(confirm("Delete play?")) {
            annotations = annotations.filter(a => a.id !== id);
            renderAnnotations();
            performAutoSave();
        }
    }

    function renderAnnotations() {
        const list = document.getElementById('annotation-list');
        list.innerHTML = "";
        if (annotations.length === 0) {
            list.innerHTML = `<li class="annotation-item" style="justify-content:center; color:#666;">No saved plays.</li>`;
            return;
        }
        annotations.forEach(note => {
            const li = document.createElement('li');
            li.className = 'annotation-item';
            li.onclick = () => loadAnnotation(note.id);
            li.innerHTML = `
                <div style="display:flex; align-items:center;">
                    <span class="annotation-time">${formatTime(note.time)}</span>
                    <span class="annotation-name">${note.name}</span>
                </div>
                <button class="delete-btn" onclick="deleteAnnotation(${note.id}, event)" style="background:none;border:none;color:#888;">&#10005;</button>
            `;
            list.appendChild(li);
        });
    }

    // --- EXPORT / IMPORT ---
    function exportPlaybook() {
        if (!player) return;
        const dataStr = JSON.stringify({
            videoId: player.getVideoData().video_id,
            plays: annotations
        });
        const link = document.createElement('a');
        link.href = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        link.download = 'playbook.json';
        link.click();
    }

    function importPlaybook(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = JSON.parse(e.target.result);
                loadVideo(data.videoId);
                annotations = data.plays;
                renderAnnotations();
                performAutoSave();
            } catch (err) { alert("Error loading file."); }
        };
        reader.readAsText(file);
    }

    // --- DRAWING ---
    function toggleDrawMode() {
        isDrawingMode = !isDrawingMode;
        if (isDrawingMode) {
            // Disable zoom if activating drawing
            if(isZoomMode) toggleZoomMode();
            
            canvas.style.pointerEvents = 'auto';
            shield.style.pointerEvents = 'none'; 
            drawBtn.classList.add('active');
            drawBtn.innerText = "Disable Drawing";
            modeIndicator.className = "mode-drawing";
            modeIndicator.innerText = "DRAWING";
        } else {
            canvas.style.pointerEvents = 'none'; 
            shield.style.pointerEvents = 'auto';
            drawBtn.classList.remove('active');
            drawBtn.innerText = "Enable Drawing";
            modeIndicator.className = "mode-viewing";
            modeIndicator.innerText = "VIEWING";
        }
    }

    function setColor(color, btn) {
        currentColor = color;
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        saveToolState();
    }
    function setTool(tool) {
        currentTool = tool;
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`tool-${tool}`).classList.add('active');
        saveToolState();
    }
    function setShape(shape) {
        currentShape = shape;
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`shape-${shape}`).classList.add('active');
        saveToolState();
    }

    function clearCanvas(skipSave) {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        
        drawHistory = [];
        historyStep = -1;
        if(!skipSave) {
            localStorage.removeItem('tiu_active_canvas'); 
            performAutoSave();
        }
    }

    function undoLast() {
        if (historyStep > 0) {
            historyStep--;
            ctx.save();
            ctx.setTransform(1,0,0,1,0,0);
            ctx.putImageData(drawHistory[historyStep], 0, 0);
            ctx.restore();
            performAutoSave(); 
        } else if (historyStep === 0) {
            clearCanvas();
        }
    }

    function saveHistory() {
        historyStep++;
        if (historyStep < drawHistory.length) drawHistory.length = historyStep;
        drawHistory.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        if(drawHistory.length > 20) { drawHistory.shift(); historyStep--; }
    }

    // Draw Logic
    let startX, startY, lastX, lastY, snapshot;

    function getPos(e) {
        const rect = canvas.getBoundingClientRect();
        // Since the canvas is scaled in CSS via Zoom, we need to normalize the coordinates
        // The rect accounts for the zoom scale visually.
        
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        // This calculates the position relative to the element (0,0 is top left of visual canvas)
        let x = clientX - rect.left;
        let y = clientY - rect.top;

        // However, the internal coordinate system is fixed (unzoomed).
        // If we zoom in 2x, the rect is 2x bigger, so x/y are 2x bigger.
        // We must divide by the Zoom Scale to match internal coords.
        return { x: x / scale, y: y / scale };
    }

    function startDraw(e) {
        if (!isDrawingMode) return;
        if(e.type === 'touchstart') e.preventDefault();
        isDrawing = true;
        const pos = getPos(e);
        startX = lastX = pos.x; 
        startY = lastY = pos.y;
        saveHistory(); 
        
        snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height); 
        
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
    }

    function moveDraw(e) {
        if (!isDrawing) return;
        if(e.type === 'touchmove') e.preventDefault();
        const pos = getPos(e);
        const size = document.getElementById('pen-size').value;
        
        ctx.strokeStyle = currentColor;
        if(currentTool === 'highlighter') {
            ctx.globalAlpha = 0.3; ctx.lineWidth = size * 4; ctx.lineCap = 'butt';  
        } else {
            ctx.globalAlpha = 1.0; ctx.lineWidth = size; ctx.lineCap = 'round';
        }

        if (currentShape === 'free') {
            ctx.beginPath(); ctx.moveTo(lastX, lastY); ctx.lineTo(pos.x, pos.y); ctx.stroke();
            lastX = pos.x; lastY = pos.y;
        } else {
            ctx.save();
            ctx.setTransform(1,0,0,1,0,0);
            ctx.putImageData(snapshot, 0, 0);
            ctx.restore(); 
            
            ctx.beginPath();
            if (currentShape === 'arrow') drawArrow(ctx, startX, startY, pos.x, pos.y, size);
            else if (currentShape === 'circle') drawCircle(ctx, startX, startY, pos.x, pos.y);
            ctx.stroke();
        }
    }

    function endDraw() {
        if (!isDrawing) return;
        isDrawing = false;
        ctx.closePath();
        performAutoSave(); 
    }

    // Geometry Helpers
    function drawArrow(ctx, x1, y1, x2, y2, w) {
        const aw = currentTool === 'highlighter' ? w * 4 : w;
        const head = aw * 3; 
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.lineTo(x2 - head * Math.cos(angle - Math.PI / 6), y2 - head * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - head * Math.cos(angle + Math.PI / 6), y2 - head * Math.sin(angle + Math.PI / 6));
    }
    function drawCircle(ctx, x1, y1, x2, y2) {
        const r = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        ctx.arc(x1, y1, r, 0, 2 * Math.PI);
    }
    
    function saveDrawing() {
        const link = document.createElement('a');
        link.download = 'tiu-analysis-highres.png';
        link.href = canvas.toDataURL();
        link.click();
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseout', endDraw);
    canvas.addEventListener('touchstart', startDraw, {passive: false});
    canvas.addEventListener('touchmove', moveDraw, {passive: false});
    canvas.addEventListener('touchend', endDraw);
    
    // KEYBOARD SHORTCUTS
    document.addEventListener('keydown', (e) => {
        if(e.target.tagName === 'INPUT') return; 
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
        
        const key = e.key.toLowerCase();
        if (key === ' ' || key === 'k') togglePlay();
        if (key === 'f') toggleFullscreen();
        if (key === 'c' || key === 'backspace') clearCanvas();
        if (key === 'z' && (e.ctrlKey || e.metaKey)) undoLast();
        if (key === 'arrowleft') frameStep(-1);
        if (key === 'arrowright') frameStep(1);
        if (key === 'j') skipTime(-5);
        if (key === 'l') skipTime(5);
    });

    window['__onGCastApiAvailable'] = function(isAvailable) {
        if (isAvailable) {
            cast.framework.CastContext.getInstance().setOptions({
                receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
                autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED
            });
        }
    };
</script>
</body>
</html>
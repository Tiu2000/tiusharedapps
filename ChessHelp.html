<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Chess Scenario Strategist Pro ‚Äî TIU</title>
  <style>
    :root {
      --bg-color: #ffffff;
      --board-border: #333;
      --light-sq: #f0d9b5; 
      --dark-sq: #b58863;
      --accent: #2b6cb0;
      --danger: #e53e3e;     /* Red for danger */
      --danger-bg: rgba(229, 62, 62, 0.4);
      --warning: #dd6b20;
      --success: #38a169;
      --highlight: rgba(255, 255, 0, 0.5);
      --move-dot: rgba(0, 0, 0, 0.3);
      --hint-source: rgba(255, 235, 59, 0.7);
      --hint-target: rgba(76, 175, 80, 0.7); 
    }

    * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      margin: 0; padding: 10px;
      background: #f4f4f4; color: #111;
      overscroll-behavior: none;
    }

    .app {
      display: flex; flex-direction: column; gap: 16px;
      max-width: 600px; margin: 0 auto; padding-bottom: 40px;
    }

    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; }
    h1 { font-size: 20px; margin: 0; font-weight: 700; color: #222; }

    .panel {
      background: #fff; border-radius: 8px; padding: 12px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05); border: 1px solid #ddd;
    }

    .board-wrap { display: flex; flex-direction: column; align-items: center; gap: 10px; position: relative; }

    /* --- MODE TOGGLE --- */
    .mode-switch {
      display: flex; background: #eee; border-radius: 20px; padding: 4px;
      cursor: pointer; font-size: 14px; font-weight: 600; user-select: none;
      width: 100%; justify-content: center; margin-bottom: 10px;
    }
    .mode-option {
      flex: 1; text-align: center; padding: 6px 12px; border-radius: 16px;
      transition: all 0.2s; color: #666;
    }
    .mode-option.active { background: white; color: var(--accent); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .mode-option.active-edit { color: var(--danger); }

    /* --- RISK TOGGLE --- */
    .risk-toggle {
        display: flex; align-items: center; gap: 8px; font-size: 14px; font-weight: 600;
        cursor: pointer; margin-bottom: 5px;
    }
    .risk-checkbox { width: 18px; height: 18px; accent-color: var(--danger); }

    /* --- BOARD STYLING --- */
    .board {
      width: 100%; max-width: 90vw; height: 90vw; 
      max-height: 500px; max-width: 500px;
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border: 3px solid #333;
      user-select: none;
      background: #eee;
      position: relative;
    }
    @media (min-width: 555px) { .board { height: 500px; } }

    .square {
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      font-size: clamp(24px, 8vw, 42px);
      position: relative; cursor: pointer;
    }
    .sq-light { background: var(--light-sq); }
    .sq-dark { background: var(--dark-sq); }

    /* Threat Highlight */
    .sq-risk { 
        box-shadow: inset 0 0 0 3px var(--danger) !important; 
        background-color: var(--danger-bg) !important;
    }
    .sq-risk::after {
        content: '!'; position: absolute; top: 2px; right: 2px;
        font-size: 10px; font-weight: bold; color: var(--danger);
    }

    .hint-source { background-color: var(--hint-source) !important; box-shadow: inset 0 0 0 2px #fbc02d; }
    .hint-target { background-color: var(--hint-target) !important; box-shadow: inset 0 0 0 2px #2e7d32; }
    .hint-target::after {
      content: 'üéØ'; position: absolute; font-size: clamp(16px, 4vw, 24px); z-index: 5; opacity: 0.8; pointer-events: none;
    }

    .piece {
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      line-height: 1; pointer-events: none; z-index: 2;
    }

    .brand-watermark {
      position: absolute; bottom: 5px; right: 5px;
      font-size: 10px; font-weight: 900; color: rgba(0,0,0,0.15);
      pointer-events: none; z-index: 1; font-family: monospace;
    }

    /* --- UI ELEMENTS --- */
    .selected { background: var(--highlight) !important; }
    .legal-dot {
      position: absolute; width: 25%; height: 25%;
      background: var(--move-dot); border-radius: 50%; pointer-events: none;
    }
    .legal-capture::before {
      content: ''; position: absolute; width: 80%; height: 80%;
      border: 5px solid rgba(0,0,0,0.3); border-radius: 50%;
    }
    
    .edit-border { border-color: var(--danger) !important; }
    .edit-indicator {
      position: absolute; top: 5px; left: 5px;
      background: var(--danger); color: white;
      font-size: 10px; padding: 2px 6px; border-radius: 4px;
      font-weight: bold; pointer-events: none; z-index: 10;
      display: none;
    }

    .btn {
      background: #fff; border: 1px solid #ccc; padding: 8px 12px;
      border-radius: 6px; font-size: 14px; cursor: pointer; color: #333; font-weight: 600;
    }
    .btn:active { background: #eee; }
    .btn.primary { background: var(--accent); color: #fff; border: none; }
    .btn.danger { background: var(--danger); color: #fff; border: none; }
    .btn-group { display: flex; gap: 8px; }

    textarea { width: 100%; height: 60px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; }
    
    .palette { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; margin-top: 10px; }
    .cell {
      aspect-ratio: 1; background: #f9f9f9; border: 1px solid #ccc;
      border-radius: 4px; display: flex; align-items: center; justify-content: center;
      font-size: 24px; cursor: pointer;
    }
    .cell.active { background: #dceefc; border-color: var(--accent); }
    .remove-cell { color: red; font-weight: bold; }

    .collapsible-header { padding: 10px 0; font-weight: bold; cursor: pointer; display: flex; justify-content: space-between; }
    .collapsible-content { display: none; padding-top: 10px; }
    .collapsible-content.show { display: block; }

    .turn-badge {
        padding: 4px 10px; background: #eee; border-radius: 12px; cursor: pointer;
        border: 1px solid #ccc; font-weight: bold; display: inline-flex; align-items: center; gap: 5px;
    }
    .turn-badge:hover { background: #ddd; }

    /* Alert Box for Risks */
    .alert-box {
        background: #fff5f5; border-left: 4px solid var(--danger);
        padding: 10px; margin-top: 10px; font-size: 13px; color: #c53030;
        display: none;
    }
    .alert-box.visible { display: block; }
  </style>
</head>
<body>

<div class="app">
  <header>
    <h1>Scenario Strategist Pro</h1>
    <div class="btn-group">
      <button class="btn" onclick="flipBoard()">Flip</button>
      <button class="btn danger" onclick="resetBoard()">Reset</button>
      <button class="btn primary" onclick="startPos()">Start</button>
    </div>
  </header>

  <main class="panel board-wrap">
    <div class="mode-switch" onclick="toggleMode()">
        <div id="modePlay" class="mode-option active">Play Mode</div>
        <div id="modeEdit" class="mode-option">Free Edit Mode</div>
    </div>

    <div style="width:100%; display:flex; justify-content:space-between; align-items:center;">
      <div class="turn-badge" onclick="manualSwapTurn()" title="Click to swap turn">
        <span>Turn:</span><span id="turnText">White</span>
      </div>
      <label class="risk-toggle">
          <input type="checkbox" class="risk-checkbox" id="riskCheck" onchange="toggleRiskMap()">
          Show Danger Map
      </label>
    </div>
    
    <div id="board" class="board">
       <div id="editFlag" class="edit-indicator">FREE MODE</div>
    </div>
    
    <div id="riskAlert" class="alert-box">
        <strong>‚ö†Ô∏è Threat Detected:</strong> <span id="riskText"></span>
    </div>
  </main>

  <aside class="panel">
    <div onclick="toggle(this)" class="collapsible-header">
      <span>Piece Palette</span> <span>‚ñº</span>
    </div>
    <div class="collapsible-content show">
      <div id="palette" class="palette"></div>
      <p style="font-size:12px; color:#666; margin-top:5px;">Tap to place. Free Mode allows placing anywhere.</p>
    </div>
    
    <div style="border-top:1px solid #eee; margin:10px 0;"></div>

    <div onclick="toggle(this)" class="collapsible-header">
      <span>Smart Analysis</span> <span>‚ñº</span>
    </div>
    <div class="collapsible-content show">
      <div class="btn-group" style="margin-top:5px;">
        <button class="btn primary" onclick="findBestMove()" style="width:100%">Find Best Move</button>
      </div>
      <div id="engineOut" style="margin-top:10px; font-family:monospace; background:#f0f7ff; padding:8px; border-radius:4px; font-size:13px;">Ready</div>
      <textarea id="fen" style="margin-top:10px;" placeholder="FEN String"></textarea>
      <button class="btn" style="margin-top:5px; width:100%;" onclick="loadFen()">Load FEN</button>
    </div>
  </aside>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script>
  // --- STATE ---
  let chess = null;
  let selectedSquare = null;
  let selectedPiece = null;
  let isFreeMode = false;
  let showRisk = false;

  // --- INIT & PERSISTENCE ---
  (function drawEmptyBoard() {
    const boardEl = document.getElementById('board');
    let html = '<div id="editFlag" class="edit-indicator">FREE MODE</div>';
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const squareColor = (r + c) % 2 === 0 ? 'sq-light' : 'sq-dark';
        const squareName = String.fromCharCode(97 + c) + (8 - r);
        html += `<div class="square ${squareColor}" data-square="${squareName}" id="sq-${squareName}"></div>`;
      }
    }
    html += '<div class="brand-watermark">TIU</div>';
    boardEl.innerHTML = html;
  })();

  window.onload = function() {
    if (typeof Chess === 'undefined') {
      alert("Engine failed. Check connection.");
    } else {
      chess = new Chess();
      // Load saved state if exists
      const savedFen = localStorage.getItem('tiu_chess_fen');
      if (savedFen) {
          chess.load(savedFen);
      }
      init();
    }
  };

  function init() {
    renderPieces(); 
    renderPalette();
    updateStatus();
    analyzeThreats(); // Run risk calc on load
    
    document.querySelectorAll('.square').forEach(sq => {
      sq.onclick = () => handleSquareClick(sq.dataset.square);
    });
  }

  function saveState() {
      if(chess) localStorage.setItem('tiu_chess_fen', chess.fen());
  }

  // --- RISK LOGIC ---
  function toggleRiskMap() {
      showRisk = document.getElementById('riskCheck').checked;
      renderPieces(); // Re-render to show/hide red squares
      analyzeThreats();
  }

  function getAttackedSquares(attackingColor) {
      // Create a temporary chess instance to check opponent moves
      const tempChess = new Chess(chess.fen());
      
      // Force turn to attacking color to get their moves
      // We do this by hacking the FEN (swapping w/b) if needed
      const currentTurn = tempChess.turn();
      if (currentTurn !== attackingColor) {
          const parts = tempChess.fen().split(' ');
          parts[1] = attackingColor;
          parts[3] = '-'; 
          tempChess.load(parts.join(' '));
      }
      
      const moves = tempChess.moves({ verbose: true });
      const attacked = new Set();
      
      moves.forEach(m => {
          attacked.add(m.to);
      });
      return attacked;
  }

  function analyzeThreats() {
      if(!chess) return;
      
      const myColor = chess.turn();
      const oppColor = myColor === 'w' ? 'b' : 'w';
      const attackedSquares = getAttackedSquares(oppColor);
      
      // 1. Highlight Danger Zones (if enabled)
      if (showRisk) {
          document.querySelectorAll('.square').forEach(el => el.classList.remove('sq-risk'));
          attackedSquares.forEach(sq => {
              const el = document.getElementById('sq-' + sq);
              if(el) el.classList.add('sq-risk');
          });
      } else {
          document.querySelectorAll('.sq-risk').forEach(el => el.classList.remove('sq-risk'));
      }

      // 2. Text Alert for hanging pieces
      const myPiecesUnderAttack = [];
      const board = chess.board();
      
      for(let r=0; r<8; r++) {
          for(let c=0; c<8; c++) {
              const p = board[r][c];
              if(p && p.color === myColor) {
                  const sq = String.fromCharCode(97 + c) + (8 - r);
                  if (attackedSquares.has(sq)) {
                      myPiecesUnderAttack.push(`${p.type.toUpperCase()} on ${sq}`);
                  }
              }
          }
      }

      const alertBox = document.getElementById('riskAlert');
      const alertText = document.getElementById('riskText');
      
      if (myPiecesUnderAttack.length > 0) {
          alertBox.classList.add('visible');
          alertText.innerText = myPiecesUnderAttack.slice(0, 3).join(', ') + (myPiecesUnderAttack.length > 3 ? '...' : '');
      } else {
          alertBox.classList.remove('visible');
      }
  }

  // --- GAME LOGIC ---

  function toggleMode() {
    isFreeMode = !isFreeMode;
    document.getElementById('modePlay').classList.toggle('active');
    document.getElementById('modeEdit').classList.toggle('active');
    document.getElementById('modeEdit').classList.toggle('active-edit');
    
    const board = document.getElementById('board');
    const flag = document.getElementById('editFlag');
    
    if (isFreeMode) {
      board.classList.add('edit-border');
      flag.style.display = 'block';
      clearHints();
      document.querySelectorAll('.legal-dot, .legal-capture').forEach(e => e.remove());
    } else {
      board.classList.remove('edit-border');
      flag.style.display = 'none';
      selectedSquare = null;
      renderPieces();
    }
  }

  function handleSquareClick(sq) {
    if (!chess) return; 
    clearHints();

    // 1. PALETTE
    if (selectedPiece) {
      if (selectedPiece === 'remove') {
        chess.remove(sq);
      } else {
        const color = selectedPiece[0];
        const type = selectedPiece[1].toLowerCase();
        chess.remove(sq);
        chess.put({ type, color }, sq);
      }
      saveState(); renderPieces(); updateStatus(); analyzeThreats();
      return;
    }

    // 2. FREE MODE
    if (isFreeMode) {
        if (selectedSquare) {
            const piece = chess.get(selectedSquare);
            if (piece) {
                chess.remove(selectedSquare);
                chess.remove(sq);
                chess.put(piece, sq);
            }
            selectedSquare = null;
            saveState(); renderPieces(); updateStatus(); analyzeThreats();
        } else {
            const piece = chess.get(sq);
            if (piece) { selectedSquare = sq; renderPieces(); }
        }
        return;
    }

    // 3. PLAY MODE
    if (selectedSquare) {
      const move = chess.move({ from: selectedSquare, to: sq, promotion: 'q' });
      
      if (move) {
        selectedSquare = null;
        saveState(); renderPieces(); updateStatus(); analyzeThreats();
      } else {
        const piece = chess.get(sq);
        if (piece && piece.color === chess.turn()) {
            selectedSquare = sq; renderPieces(); showLegalMoves(sq);
        } else {
            selectedSquare = null; renderPieces();
        }
      }
      return;
    }

    const piece = chess.get(sq);
    if (piece && piece.color === chess.turn()) {
      selectedSquare = sq; renderPieces(); showLegalMoves(sq);
    }
  }

  function showLegalMoves(sq) {
    const moves = chess.moves({ square: sq, verbose: true });
    moves.forEach(m => {
      const target = document.getElementById(`sq-${m.to}`);
      if (target) {
        const dot = document.createElement('div');
        dot.className = m.captured ? 'legal-capture' : 'legal-dot';
        target.appendChild(dot);
      }
    });
  }

  function manualSwapTurn() {
     if(!chess) return;
     const fen = chess.fen();
     const parts = fen.split(' ');
     parts[1] = parts[1] === 'w' ? 'b' : 'w'; 
     parts[3] = '-';
     chess.load(parts.join(' '));
     saveState(); updateStatus(); renderPieces(); analyzeThreats();
  }

  function renderPieces() {
    document.querySelectorAll('.piece, .legal-dot, .legal-capture').forEach(e => e.remove());
    document.querySelectorAll('.square').forEach(e => e.classList.remove('selected'));
    
    // Maintain Risk Highlight
    if(showRisk) {
        const myColor = chess.turn();
        const oppColor = myColor === 'w' ? 'b' : 'w';
        const attacked = getAttackedSquares(oppColor);
        document.querySelectorAll('.square').forEach(el => el.classList.remove('sq-risk'));
        attacked.forEach(sq => {
           const el = document.getElementById('sq-'+sq);
           if(el) el.classList.add('sq-risk');
        });
    } else {
        document.querySelectorAll('.sq-risk').forEach(el => el.classList.remove('sq-risk'));
    }

    const board = chess.board();
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        const squareName = String.fromCharCode(97 + c) + (8 - r);
        const sqDiv = document.getElementById(`sq-${squareName}`);
        
        if (piece && sqDiv) {
          const pDiv = document.createElement('div');
          pDiv.className = 'piece';
          pDiv.innerText = getPieceSymbol(piece);
          sqDiv.appendChild(pDiv);
        }
        if (selectedSquare === squareName && sqDiv) {
          sqDiv.classList.add('selected');
        }
      }
    }
  }

  function updateStatus() {
    if(!chess) return;
    const t = chess.turn() === 'w' ? 'White' : 'Black';
    document.getElementById('turnText').innerText = t;
    document.getElementById('fen').value = chess.fen();
  }

  function getPieceSymbol(p) {
    const symbols = {
      wK:'‚ôî', wQ:'‚ôï', wR:'‚ôñ', wB:'‚ôó', wN:'‚ôò', wP:'‚ôô',
      bK:'‚ôö', bQ:'‚ôõ', bR:'‚ôú', bB:'‚ôù', bN:'‚ôû', bP:'‚ôü'
    };
    return symbols[(p.color === 'w' ? 'w' : 'b') + p.type.toUpperCase()];
  }

  function renderPalette() {
    const pieces = ['wK','wQ','wR','wB','wN','wP','bK','bQ','bR','bB','bN','bP'];
    const paletteEl = document.getElementById('palette');
    paletteEl.innerHTML = '';
    pieces.forEach(p => {
      const type = p[1].toLowerCase();
      const color = p[0];
      const el = document.createElement('div');
      el.className = 'cell';
      el.innerText = getPieceSymbol({type, color});
      el.onclick = () => {
         selectedPiece = (selectedPiece === p) ? null : p;
         selectedSquare = null; clearHints();
         document.querySelectorAll('.cell').forEach(c => c.classList.remove('active'));
         if(selectedPiece) el.classList.add('active');
      };
      paletteEl.appendChild(el);
    });
    const del = document.createElement('div');
    del.className = 'cell remove-cell';
    del.innerText = '‚úï';
    del.onclick = () => {
        selectedPiece = (selectedPiece === 'remove') ? null : 'remove';
        selectedSquare = null; clearHints();
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('active'));
        if(selectedPiece) del.classList.add('active');
    };
    paletteEl.appendChild(del);
  }

  function clearHints() {
    document.querySelectorAll('.hint-source, .hint-target').forEach(el => {
      el.classList.remove('hint-source', 'hint-target');
    });
  }

  function startPos() { if(chess) { chess.reset(); saveState(); init(); } }
  function resetBoard() { if(chess) { chess.clear(); saveState(); init(); } }
  function undo() { if(chess) { chess.undo(); saveState(); init(); } }
  
  function loadFen() { 
    if(!chess) return;
    const val = document.getElementById('fen').value; 
    if(chess.load(val)) { saveState(); init(); } 
    else alert('Invalid FEN');
  }
  
  function flipBoard() {
    const b = document.getElementById('board');
    const isRotated = b.style.transform === 'rotate(180deg)';
    b.style.transform = isRotated ? '' : 'rotate(180deg)';
    document.querySelectorAll('.piece').forEach(p => { p.style.transform = isRotated ? '' : 'rotate(180deg)'; });
    const brand = document.querySelector('.brand-watermark');
    if(brand) brand.style.transform = isRotated ? '' : 'rotate(180deg)';
  }
  
  function toggle(el) { el.nextElementSibling.classList.toggle('show'); }

  // --- SMART BOT ---
  function findBestMove() {
     if(!chess) return;
     clearHints();
     
     const moves = chess.moves({ verbose: true });
     if(moves.length === 0) { 
        document.getElementById('engineOut').innerText = "None (Mate/Stale)"; 
        return; 
     }
     
     // SMART LOGIC: Prioritize Captures
     let bestMove = null;
     
     // 1. Look for captures (Basic heuristic)
     const captures = moves.filter(m => m.captured);
     if (captures.length > 0) {
         // Pick random capture for now (or could sort by value)
         bestMove = captures[Math.floor(Math.random() * captures.length)];
         document.getElementById('engineOut').innerText = `Best: Capture ${bestMove.captured} on ${bestMove.to}`;
     } else {
         // 2. Otherwise random
         bestMove = moves[Math.floor(Math.random() * moves.length)];
         document.getElementById('engineOut').innerText = `Best: Strategic Move to ${bestMove.to}`;
     }
     
     const sourceSq = document.getElementById('sq-' + bestMove.from);
     const targetSq = document.getElementById('sq-' + bestMove.to);
     if (sourceSq) sourceSq.classList.add('hint-source');
     if (targetSq) targetSq.classList.add('hint-target');
  }
</script>
</body>
</html>
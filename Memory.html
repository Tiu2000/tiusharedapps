<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Memory (Strict Sync)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #121212;
            --surface: #1e1e1e;
            --primary: #bb86fc;
            --secondary: #03dac6;
            --error: #cf6679;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* LOBBY */
        #lobby {
            background: var(--surface);
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        input {
            padding: 10px; font-size: 1rem; border-radius: 4px; border: none; text-align: center;
            margin-bottom: 15px; width: 200px;
        }
        button {
            padding: 10px 20px; cursor: pointer; font-weight: bold; border: none; border-radius: 4px;
            margin: 5px; transition: 0.2s;
        }
        button:hover { filter: brightness(1.2); }
        .btn-host { background: var(--primary); color: #000; }
        .btn-join { background: var(--secondary); color: #000; }

        /* GAME UI */
        #game-ui {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 600px;
        }

        .header-bar {
            display: flex; justify-content: space-between; width: 100%; margin-bottom: 20px;
            background: var(--surface); padding: 10px 20px; border-radius: 8px; box-sizing: border-box;
        }
        .score-box { text-align: center; }
        .score-val { font-size: 1.5rem; font-weight: bold; display: block;}
        .active-p { color: var(--secondary); text-shadow: 0 0 10px var(--secondary); }
        
        #game-id-display {
            position: absolute; top: 10px; right: 10px; font-family: monospace; opacity: 0.5; font-size: 0.8rem;
        }

        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
        }
        .card {
            width: 70px; height: 100px; position: relative;
            transform-style: preserve-3d; transition: transform 0.5s; cursor: pointer;
        }
        .card.flipped, .card.matched { transform: rotateY(180deg); }
        .card.matched { opacity: 0.5; }
        
        .face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem; border-radius: 8px; border: 2px solid #333;
        }
        .front { background: #2c2c2c; } /* Back of card (visible initially) */
        .front::after { content: "?"; color: #555; }
        .back { background: white; transform: rotateY(180deg); color: black; } /* Emoji side */

        #status-msg { margin-top: 15px; color: #aaa; font-style: italic; }

    </style>
</head>
<body>

    <div id="game-id-display"></div>

    <div id="lobby">
        <h2>TIU Memory P2P</h2>
        <input type="text" id="room-input" placeholder="Room Name (e.g. apple)" maxlength="10">
        <br>
        <button class="btn-host" onclick="startHost()">Host Game</button>
        <button class="btn-join" onclick="startGuest()">Join Game</button>
        <div id="lobby-log" style="margin-top:10px; color:#888; font-size:0.9rem;"></div>
    </div>

    <div id="game-ui">
        <div class="header-bar">
            <div id="p1-ui" class="score-box active-p">HOST<span id="s1" class="score-val">0</span></div>
            <div style="align-self:center; font-size: 0.8rem; color:#888;">VS</div>
            <div id="p2-ui" class="score-box">GUEST<span id="s2" class="score-val">0</span></div>
        </div>
        <div id="grid" class="grid"></div>
        <div id="status-msg">Waiting for game start...</div>
    </div>

    <script>
        // --- CONFIG ---
        const PREFIX = "tiu_mem_v6_"; // Unique app ID
        const EMOJIS = ['üöÄ', 'üçï', 'üê±', 'üåµ', 'üé∏', 'üç¶', 'üíé', 'üî•'];

        // --- STATE ---
        let peer, conn;
        let myRole = null; // 'host' or 'guest'
        let deck = []; // Holds the emojis
        
        // Game Variables
        let turn = 'host';
        let scores = { host: 0, guest: 0 };
        let flipped = []; // indices of currently flipped cards
        let matched = []; // indices of matched cards
        let locked = false; // Input lock during animations

        // --- HELPER: HASH ---
        // Generates a short code from the deck array. If decks match, this code matches.
        function getDeckHash(arr) {
            let str = arr.join("");
            let hash = 0;
            for (let i=0; i<str.length; i++) hash = ((hash<<5)-hash)+str.charCodeAt(i) | 0;
            return "#" + Math.abs(hash).toString(16).substring(0,4).toUpperCase();
        }

        function log(msg) { document.getElementById('lobby-log').innerText = msg; }
        function setStatus(msg) { document.getElementById('status-msg').innerText = msg; }

        // --- HOST LOGIC ---
        function startHost() {
            const room = document.getElementById('room-input').value.toLowerCase().trim();
            if(!room) return alert("Enter room name");

            myRole = 'host';
            
            // 1. HOST GENERATES DECK ONCE
            deck = [...EMOJIS, ...EMOJIS].sort(() => Math.random() - 0.5);
            
            // 2. RENDER IMMEDIATELY
            startGameUI(); 

            log("Creating room...");
            peer = new Peer(PREFIX + room);
            
            peer.on('open', (id) => {
                log("Room Open! Waiting for player...");
            });

            peer.on('connection', (c) => {
                conn = c;
                log("Guest Connecting...");
                conn.on('open', () => {
                    log("Guest Connected!");
                    // 3. SEND DECK TO GUEST
                    send({ 
                        type: 'INIT', 
                        deck: deck, 
                        turn: turn, 
                        scores: scores 
                    });
                });
                conn.on('data', handleData);
            });
            peer.on('error', err => alert("Room taken or error: " + err.type));
        }

        // --- GUEST LOGIC ---
        function startGuest() {
            const room = document.getElementById('room-input').value.toLowerCase().trim();
            if(!room) return alert("Enter room name");

            myRole = 'guest';
            deck = []; // Guest has NO deck initially
            
            log("Connecting...");
            peer = new Peer(); // Random ID for guest
            
            peer.on('open', () => {
                conn = peer.connect(PREFIX + room, { reliable: true });
                
                conn.on('open', () => {
                    log("Connected! Waiting for Host Data...");
                    setStatus("Downloading Game State...");
                    document.getElementById('lobby').style.display = 'none';
                    document.getElementById('game-ui').style.display = 'flex';
                    document.getElementById('grid').innerHTML = "<p>Syncing Cards...</p>";
                });

                conn.on('data', handleData);
                
                // Safety: Request sync if stuck
                setTimeout(() => { if(deck.length===0) send({type: 'REQ_SYNC'}); }, 2000);
            });
            peer.on('error', () => alert("Room not found"));
        }

        // --- SHARED NETWORK HANDLER ---
        function handleData(data) {
            console.log("RX:", data);
            
            if (data.type === 'INIT') {
                // Guest receives deck here
                deck = data.deck;
                turn = data.turn;
                scores = data.scores;
                flipped = [];
                matched = [];
                startGameUI();
            }
            else if (data.type === 'REQ_SYNC' && myRole === 'host') {
                // Host resends deck if requested
                send({ type: 'INIT', deck: deck, turn: turn, scores: scores });
            }
            else if (data.type === 'CLICK') {
                // Host receives click request from Guest
                if (myRole === 'host') handleCardClick(data.index);
            }
            else if (data.type === 'STATE_UPDATE') {
                // Guest receives full state update
                flipped = data.flipped;
                matched = data.matched;
                scores = data.scores;
                turn = data.turn;
                renderBoardState(); // Update visuals
            }
        }

        function send(data) {
            if (conn && conn.open) conn.send(data);
        }

        // --- GAME UI & LOGIC ---
        function startGameUI() {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('game-ui').style.display = 'flex';
            
            // Show Hash for Verification
            const hash = getDeckHash(deck);
            document.getElementById('game-id-display').innerText = "Game ID: " + hash;

            // Build Grid
            const grid = document.getElementById('grid');
            grid.innerHTML = "";
            deck.forEach((emoji, i) => {
                const el = document.createElement('div');
                el.className = 'card';
                el.id = 'c-' + i;
                el.onclick = () => onUserClick(i);
                el.innerHTML = `
                    <div class="face front"></div>
                    <div class="face back">${emoji}</div>
                `;
                grid.appendChild(el);
            });
            renderBoardState();
        }

        function onUserClick(index) {
            if (locked) return;
            // If Host: Execute Logic
            if (myRole === 'host') {
                handleCardClick(index);
            } 
            // If Guest: Ask Host
            else {
                send({ type: 'CLICK', index: index });
            }
        }

        // --- CENTRAL LOGIC (RUNS ON HOST ONLY) ---
        function handleCardClick(index) {
            // Validation
            if (matched.includes(index)) return;
            if (flipped.includes(index)) return;
            
            // Turn validation
            if (turn !== 'host' && myRole === 'host' && turn !== 'guest') return; // Should not happen
            
            // Add to flipped
            flipped.push(index);
            broadcastState();

            // Check Match
            if (flipped.length === 2) {
                locked = true; // Lock inputs
                setTimeout(checkMatch, 600);
            }
        }

        function checkMatch() {
            const [i1, i2] = flipped;
            const isMatch = deck[i1] === deck[i2];

            if (isMatch) {
                matched.push(i1, i2);
                if (turn === 'host') scores.host++; else scores.guest++;
                flipped = [];
                checkWin();
            } else {
                flipped = [];
                // Switch Turn
                turn = (turn === 'host') ? 'guest' : 'host';
            }
            
            locked = false;
            broadcastState();
        }

        function checkWin() {
            if (matched.length === deck.length) {
                const winMsg = scores.host > scores.guest ? "HOST WINS!" : "GUEST WINS!";
                setStatus(winMsg + " (Reload to play again)");
            }
        }

        function broadcastState() {
            renderBoardState(); // Update Host Screen
            // Send to Guest
            send({
                type: 'STATE_UPDATE',
                flipped: flipped,
                matched: matched,
                scores: scores,
                turn: turn
            });
        }

        // --- VISUAL RENDERER ---
        function renderBoardState() {
            // Update Cards
            for (let i = 0; i < deck.length; i++) {
                const card = document.getElementById('c-' + i);
                if (!card) continue;
                
                // Remove classes first
                card.classList.remove('flipped', 'matched');
                
                // Re-add based on state
                if (flipped.includes(i)) card.classList.add('flipped');
                if (matched.includes(i)) card.classList.add('matched');
            }

            // Update Scores & Turn
            document.getElementById('s1').innerText = scores.host;
            document.getElementById('s2').innerText = scores.guest;
            
            const p1 = document.getElementById('p1-ui');
            const p2 = document.getElementById('p2-ui');
            
            p1.classList.remove('active-p');
            p2.classList.remove('active-p');
            
            if (turn === 'host') {
                p1.classList.add('active-p');
                setStatus(myRole === 'host' ? "Your Turn" : "Host's Turn");
            } else {
                p2.classList.add('active-p');
                setStatus(myRole === 'guest' ? "Your Turn" : "Guest's Turn");
            }
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>P2P Memory Match (V29 Fixed)</title>
<script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Arial', sans-serif;
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
  color: #00ffff;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  user-select: none;
}
.container { max-width: 600px; width: 100%; }
h1 {
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 0 20px #00ffff;
  font-size: 2em;
}
.menu {
  background: #1a1a2e;
  padding: 30px;
  border-radius: 15px;
  border: 2px solid #00ffff;
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
  text-align: center;
}
.btn {
  background: #00ffff;
  color: #000;
  border: none;
  padding: 15px 30px;
  font-size: 1.2em;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  margin: 10px;
  transition: all 0.3s;
  width: 100%;
  max-width: 300px;
}
.btn:hover {
  background: #00cccc;
  transform: scale(1.05);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}
.input-group {
  margin: 20px 0;
}
.input-group input {
  background: #0a0a0a;
  border: 2px solid #00ffff;
  color: #00ffff;
  padding: 12px;
  font-size: 1.1em;
  border-radius: 8px;
  width: 200px;
  text-align: center;
  text-transform: uppercase;
  letter-spacing: 3px;
  font-weight: bold;
}
.game-view {
  display: none;
}
.status-bar {
  background: #1a1a2e;
  padding: 20px;
  border-radius: 15px;
  border: 2px solid #00ffff;
  margin-bottom: 20px;
}
.turn-banner {
  text-align: center;
  font-size: 1.5em;
  font-weight: bold;
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 15px;
}
.your-turn { background: #00ff00; color: #000; box-shadow: 0 0 15px #00ff00; }
.opponent-turn { background: #333; color: #888; border: 1px solid #555; }

.scoreboard {
  display: flex;
  justify-content: space-around;
  margin-bottom: 15px;
}
.player-card {
  background: #0a0a0a;
  padding: 15px;
  border-radius: 10px;
  border: 2px solid #555;
  flex: 1;
  margin: 0 10px;
  text-align: center;
  transition: 0.3s;
}
.player-card.active {
  border-color: #00ffff;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
  background: #0f1f2f;
}
.player-card h3 {
  font-size: 0.9em;
  margin-bottom: 5px;
  color: #aaa;
}
.player-card .score {
  font-size: 2.5em;
  font-weight: bold;
  color: #fff;
}
.network-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.9em;
  color: #888;
  margin-top: 10px;
}
.pulse {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #333;
  display: inline-block;
  margin-left: 5px;
}
.pulse.active {
  background: #00ff00;
  box-shadow: 0 0 8px #00ff00;
}
.board {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 15px;
  margin-bottom: 20px;
  perspective: 1000px;
}
.card {
  aspect-ratio: 4/5;
  background: transparent;
  cursor: pointer;
  position: relative;
  transform-style: preserve-3d;
  transition: transform 0.4s;
}
.card.flipped, .card.matched {
  transform: rotateY(180deg);
}
.card.matched {
  opacity: 0.6;
  cursor: default;
}
.face {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2.5em;
  border: 2px solid #00ffff;
  box-shadow: 0 4px 6px rgba(0,0,0,0.3);
}
.front {
  background: #1a1a2e;
  background-image: linear-gradient(135deg, rgba(0,255,255,0.1) 25%, transparent 25%, transparent 50%, rgba(0,255,255,0.1) 50%, rgba(0,255,255,0.1) 75%, transparent 75%, transparent);
  background-size: 10px 10px;
}
.back {
  background: #0a0a0a;
  transform: rotateY(180deg);
  border-color: #fff;
  color: #fff;
}

.debug-console {
  background: #000;
  border: 1px solid #333;
  border-radius: 10px;
  padding: 10px;
  height: 100px;
  overflow-y: auto;
  font-family: 'Courier New', monospace;
  font-size: 0.7em;
  color: #00ff00;
  margin-bottom: 20px;
}
.controls {
  display: flex;
  justify-content: center;
  gap: 10px;
}
.btn-small {
  padding: 10px 20px;
  font-size: 0.9em;
  width: auto;
}
.btn-danger {
    background: #ff3333;
    color: white;
}
</style>
</head>
<body onclick="resumeAudio()">

<div class="container">
  <h1>üéÆ NEON MEMORY</h1>
  
  <div id="menu" class="menu">
    <h2 style="margin-bottom: 20px;">MULTIPLAYER LOBBY</h2>
    <button class="btn" onclick="createGame()">üè† HOST GAME</button>
    
    <div style="margin: 20px 0; color: #555;">‚Äî OR ‚Äî</div>
    
    <div class="input-group">
      <input type="text" id="roomCode" placeholder="ENTER CODE" maxlength="4" oninput="this.value=this.value.toUpperCase()">
    </div>
    <button class="btn" onclick="joinGame()">üöÄ JOIN GAME</button>
  </div>

  <div id="gameView" class="game-view">
    <div class="status-bar">
      <div id="turnBanner" class="turn-banner">WAITING...</div>
      
      <div class="scoreboard">
        <div class="player-card" id="hostCard">
          <h3>HOST</h3>
          <div class="score" id="hostScore">0</div>
        </div>
        <div class="player-card" id="guestCard">
          <h3>GUEST</h3>
          <div class="score" id="guestScore">0</div>
        </div>
      </div>

      <div class="network-info">
        <span id="roomInfo">Room: ----</span>
        <span>Signal: <span class="pulse" id="pulse"></span></span>
      </div>
    </div>

    <div class="board" id="board"></div>

    <div class="debug-console" id="debugConsole"><div>System Ready...</div></div>

    <div class="controls">
      <button class="btn btn-small" onclick="forceSync()">üîÑ RESYNC</button>
      <button class="btn btn-small btn-danger" onclick="location.reload()">üõë EXIT</button>
    </div>
  </div>
</div>

<script>
// --- CONFIGURATION ---
const APP_PREFIX = "neon-mem-v29-"; // Unique ID prefix to find peers
const EMOJIS = ['üöÄ', 'üçï', 'üê±', 'üéÆ', 'üåü', 'üé®', 'üé≠', 'üî•'];

// --- AUDIO SYSTEM ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function resumeAudio() { if (audioCtx.state === 'suspended') audioCtx.resume(); }

function playSound(type) {
  resumeAudio();
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  const now = audioCtx.currentTime;
  
  if (type === 'flip') {
    osc.type = 'sine';
    osc.frequency.setValueAtTime(400, now);
    osc.frequency.linearRampToValueAtTime(600, now + 0.1);
  } else if (type === 'match') {
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(440, now);
    osc.frequency.setValueAtTime(880, now + 0.1);
  } else {
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.linearRampToValueAtTime(100, now + 0.2);
  }
  
  gain.gain.setValueAtTime(0.1, now);
  gain.gain.linearRampToValueAtTime(0.001, now + 0.2);
  
  osc.start(now);
  osc.stop(now + 0.2);
}

// --- GAME STATE ---
let peer = null;
let role = null; // 'host' or 'guest'
let connections = []; // For Host
let hostConn = null;  // For Guest
let syncTimer = null;

const gameState = {
  deck: [],
  flipped: [],
  matched: [],
  turn: 'host',
  scores: { host: 0, guest: 0 },
  locked: false
};

// --- LOGGING ---
function log(msg) {
  const c = document.getElementById('debugConsole');
  const d = document.createElement('div');
  d.textContent = `> ${msg}`;
  c.prepend(d);
}

function flashPulse() {
  const p = document.getElementById('pulse');
  p.classList.add('active');
  setTimeout(() => p.classList.remove('active'), 200);
}

// --- HOST LOGIC ---
function createGame() {
  role = 'host';
  const code = Math.random().toString(36).substring(2, 6).toUpperCase();
  const peerId = APP_PREFIX + code;
  
  peer = new Peer(peerId);
  
  peer.on('open', (id) => {
    log(`Hosting Room: ${code}`);
    document.getElementById('roomInfo').textContent = `Room: ${code}`;
    
    // Init Game Data
    gameState.deck = [...EMOJIS, ...EMOJIS].sort(() => Math.random() - 0.5);
    gameState.flipped = [];
    gameState.matched = [];
    gameState.turn = 'host';
    gameState.scores = { host: 0, guest: 0 };
    
    showGame();
    renderBoard();
    updateUI();
  });
  
  peer.on('connection', (conn) => {
    log(`Guest joined!`);
    connections.push(conn);
    
    conn.on('open', () => {
      broadcast(); // Send state immediately
    });
    
    conn.on('data', (data) => {
      flashPulse();
      if (data.type === 'CLICK') handleCardClick(data.index, true);
      if (data.type === 'SYNC_REQ') broadcast();
    });

    conn.on('close', () => {
      log("Guest disconnected");
      connections = connections.filter(c => c !== conn);
    });
  });

  peer.on('error', (err) => {
    alert("Error: " + err.type);
    log("Error: " + err.type);
  });
}

// --- GUEST LOGIC ---
function joinGame() {
  const code = document.getElementById('roomCode').value.trim().toUpperCase();
  if (code.length !== 4) return alert("Please enter a 4-letter code");
  
  role = 'guest';
  log(`Connecting to ${code}...`);
  
  peer = new Peer(); // Guest gets random ID
  
  peer.on('open', () => {
    const hostId = APP_PREFIX + code;
    hostConn = peer.connect(hostId, { reliable: true });
    
    hostConn.on('open', () => {
      log("Connected! Downloading data...");
      showGame();
      document.getElementById('roomInfo').textContent = `Room: ${code}`;
      
      // Polling for initial state
      requestSync();
      syncTimer = setInterval(() => {
        if(gameState.deck.length === 0) requestSync();
        else clearInterval(syncTimer);
      }, 1000);
    });
    
    hostConn.on('data', (data) => {
      flashPulse();
      if (data.type === 'STATE') {
        Object.assign(gameState, data.data);
        renderBoard();
        updateUI();
        if(data.sfx) playSound(data.sfx);
      }
    });

    hostConn.on('close', () => {
      alert("Host disconnected");
      location.reload();
    });
  });

  peer.on('error', (err) => {
    if(err.type === 'peer-unavailable') alert("Room not found!");
    log("Error: " + err.type);
  });
}

// --- NETWORKING ---
function broadcast(sfx = null) {
  connections.forEach(c => {
    if (c.open) c.send({ type: 'STATE', data: gameState, sfx: sfx });
  });
}

function requestSync() {
  if (hostConn && hostConn.open) hostConn.send({ type: 'SYNC_REQ' });
}

function forceSync() {
  if (role === 'guest') requestSync();
  else broadcast();
  log("Sync requested");
}

// --- GAMEPLAY ---
function handleCardClick(index, isRemote = false) {
  // Validation
  if (gameState.locked) return;
  if (gameState.matched.includes(index)) return;
  if (gameState.flipped.includes(index)) return;
  
  // Turn Check
  if (role === 'host' && gameState.turn !== 'host') return;
  if (role === 'guest' && gameState.turn !== 'guest' && !isRemote) return;

  // Guest Logic: Send click to host
  if (role === 'guest' && !isRemote) {
    if (hostConn && hostConn.open) hostConn.send({ type: 'CLICK', index });
    return;
  }

  // Host Logic: Execute Move
  playSound('flip');
  gameState.flipped.push(index);
  broadcast('flip'); // Update Guest
  renderBoard(); // Update Host

  // Match Check
  if (gameState.flipped.length === 2) {
    gameState.locked = true;
    const [a, b] = gameState.flipped;
    const match = gameState.deck[a] === gameState.deck[b];

    setTimeout(() => {
      if (match) {
        playSound('match');
        gameState.matched.push(a, b);
        gameState.scores[gameState.turn]++;
        broadcast('match');
      } else {
        playSound('fail');
        gameState.turn = (gameState.turn === 'host' ? 'guest' : 'host');
        broadcast('fail');
      }
      gameState.flipped = [];
      gameState.locked = false;
      renderBoard();
      updateUI();
      broadcast(); // Final sync
    }, 1000);
  }
}

// --- RENDERING ---
function renderBoard() {
  const board = document.getElementById('board');
  
  // Init board if empty
  if (board.children.length === 0 && gameState.deck.length > 0) {
    gameState.deck.forEach((emoji, i) => {
      const card = document.createElement('div');
      card.className = 'card';
      card.onclick = () => handleCardClick(i);
      card.innerHTML = `<div class="face front"></div><div class="face back">${emoji}</div>`;
      board.appendChild(card);
    });
  }

  // Update states
  const cards = board.children;
  for (let i = 0; i < cards.length; i++) {
    const card = cards[i];
    const isFlipped = gameState.flipped.includes(i);
    const isMatched = gameState.matched.includes(i);
    
    if (isFlipped || isMatched) card.classList.add('flipped');
    else card.classList.remove('flipped');
    
    if (isMatched) card.classList.add('matched');
  }
}

function updateUI() {
  const isMyTurn = (role === gameState.turn);
  const banner = document.getElementById('turnBanner');
  
  if (isMyTurn) {
    banner.textContent = '‚ú® YOUR TURN';
    banner.className = 'turn-banner your-turn';
  } else {
    banner.textContent = `${gameState.turn.toUpperCase()}'S TURN`;
    banner.className = 'turn-banner opponent-turn';
  }
  
  document.getElementById('hostScore').textContent = gameState.scores.host;
  document.getElementById('guestScore').textContent = gameState.scores.guest;
  
  document.getElementById('hostCard').classList.toggle('active', gameState.turn === 'host');
  document.getElementById('guestCard').classList.toggle('active', gameState.turn === 'guest');
}

function showGame() {
  document.getElementById('menu').style.display = 'none';
  document.getElementById('gameView').style.display = 'block';
}
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Memory (Host Authoritative)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #1a1a2e;
            --card-back: #16213e;
            --card-front: #0f3460;
            --accent: #e94560;
            --text: #fff;
        }
        body {
            font-family: sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }
        .watermark {
            position: fixed; bottom: 10px; right: 20px;
            font-size: 6rem; font-weight: 900;
            color: rgba(255,255,255,0.03); transform: rotate(-15deg);
            pointer-events: none; z-index: 0;
        }
        
        /* SCREENS */
        #lobby, #game-ui {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 10;
        }
        #game-ui { display: none; width: 90%; max-width: 800px; }

        input { padding: 10px; border-radius: 5px; border: none; text-align: center; }
        button {
            padding: 10px 20px; margin: 5px; border: none; border-radius: 5px;
            cursor: pointer; font-weight: bold; transition: 0.2s;
        }
        button:hover { transform: scale(1.05); }
        .btn-host { background: var(--accent); color: white; }
        .btn-join { background: var(--card-front); color: white; }

        /* HUD */
        .hud { display: flex; justify-content: space-between; margin-bottom: 20px; width: 100%; }
        .score-box { padding: 10px 20px; background: rgba(0,0,0,0.3); border-radius: 8px; border: 2px solid transparent; }
        .active-turn { border-color: var(--accent); box-shadow: 0 0 10px var(--accent); }
        #status-text { font-style: italic; color: #ccc; align-self: center; }

        /* GRID */
        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
            perspective: 1000px; margin-bottom: 20px;
        }
        .card {
            width: 70px; height: 100px; position: relative;
            transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer;
        }
        .card.flipped, .card.matched { transform: rotateY(180deg); }
        .card.matched { opacity: 0.5; }
        
        .face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; display: flex;
            align-items: center; justify-content: center;
            font-size: 2rem; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .front { background: var(--card-front); border: 2px solid #2a4a7f; }
        .front::after { content: "TIU"; color: rgba(255,255,255,0.1); font-size: 0.8rem; transform: rotate(-45deg); }
        .back { background: white; color: #333; transform: rotateY(180deg); }

        /* DEBUG LOG */
        #debug-console {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 100px;
            background: rgba(0,0,0,0.8); color: #0f0; font-family: monospace;
            font-size: 0.8rem; overflow-y: auto; padding: 10px; display: none; z-index: 100;
            text-align: left;
        }

        @media (max-width: 500px) {
            .card { width: 55px; height: 75px; }
            .grid { gap: 8px; }
        }
    </style>
</head>
<body>

<div class="watermark">TIU</div>

<div id="lobby">
    <h2>TIU Memory P2P</h2>
    <input type="text" id="room-input" placeholder="Enter Room Name (e.g. room1)">
    <br><br>
    <button class="btn-host" onclick="initHost()">Create Room</button>
    <button class="btn-join" onclick="initGuest()">Join Room</button>
    <div id="lobby-msg" style="margin-top:10px; color:#aaa;"></div>
</div>

<div id="game-ui">
    <div class="hud">
        <div id="p1-box" class="score-box">P1 (Host): <span id="s1">0</span></div>
        <div id="status-text">Waiting...</div>
        <div id="p2-box" class="score-box">P2 (Guest): <span id="s2">0</span></div>
    </div>
    <div class="grid" id="grid"></div>
    <button onclick="toggleDebug()" style="background:none; color:#555; font-size:0.7rem;">Toggle Debug</button>
</div>

<div id="debug-console"></div>

<script>
    // --- CONFIG ---
    const APP_ID = "tiu-mem-game-final-v4-"; // Unique prefix
    const EMOJIS = ['ðŸš€', 'ðŸ•', 'ðŸ±', 'ðŸŒµ', 'ðŸŽ¸', 'ðŸ¦', 'ðŸ’Ž', 'ðŸ”¥'];
    
    // --- STATE ---
    let peer, conn;
    let isHost = false;
    let myId = "";
    
    // Game State (Host maintains truth)
    let deck = [];
    let turn = 'host'; // 'host' or 'guest'
    let scores = { host: 0, guest: 0 };
    let flipped = []; // [index, index]
    let matches = []; // [index, index, ...]
    let processing = false; // Lock interaction during timeouts

    // --- AUDIO ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSnd(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const t = audioCtx.currentTime;
        if(type==='flip'){
            osc.frequency.setValueAtTime(300,t); osc.frequency.linearRampToValueAtTime(500,t+0.1);
            gain.gain.setValueAtTime(0.2,t); gain.gain.linearRampToValueAtTime(0,t+0.1);
            osc.start(t); osc.stop(t+0.1);
        } else if(type==='match'){
            osc.type='triangle'; osc.frequency.setValueAtTime(600,t); osc.frequency.setValueAtTime(1200,t+0.2);
            gain.gain.setValueAtTime(0.2,t); gain.gain.linearRampToValueAtTime(0,t+0.3);
            osc.start(t); osc.stop(t+0.3);
        } else if(type==='nomatch'){
            osc.type='sawtooth'; osc.frequency.setValueAtTime(200,t); osc.frequency.linearRampToValueAtTime(100,t+0.3);
            gain.gain.setValueAtTime(0.2,t); gain.gain.linearRampToValueAtTime(0,t+0.3);
            osc.start(t); osc.stop(t+0.3);
        }
    }

    // --- LOGGING ---
    function log(msg) {
        const d = document.getElementById('debug-console');
        d.innerHTML += `> ${msg}<br>`;
        d.scrollTop = d.scrollHeight;
        console.log(msg);
    }
    function toggleDebug(){
        const d = document.getElementById('debug-console');
        d.style.display = d.style.display === 'none' ? 'block' : 'none';
    }

    // --- SETUP ---
    function getName(){ 
        const v = document.getElementById('room-input').value.trim().toLowerCase();
        return v ? APP_ID + v : null;
    }

    // --- HOST LOGIC ---
    function initHost() {
        const id = getName();
        if(!id) return alert("Enter Room Name");
        
        isHost = true;
        document.getElementById('lobby-msg').innerText = "Starting Server...";
        
        peer = new Peer(id);
        
        peer.on('open', () => {
            log("HOST: Peer Open. ID: " + id);
            document.getElementById('lobby-msg').innerText = "Waiting for Player 2...";
        });

        peer.on('connection', (c) => {
            log("HOST: Guest connecting...");
            conn = c;
            
            conn.on('open', () => {
                log("HOST: Connection Established!");
                startGameHost();
            });

            conn.on('data', (data) => {
                log("HOST RX: " + JSON.stringify(data));
                handleHostMessages(data);
            });
            
            conn.on('close', () => alert("Player 2 Disconnected"));
        });

        peer.on('error', err => alert("Error: " + err.type));
    }

    function startGameHost() {
        // 1. Generate Deck
        deck = [...EMOJIS, ...EMOJIS].sort(() => Math.random() - 0.5);
        
        // 2. Render Host UI
        initGameUI(deck);
        
        // 3. Send Game State to Guest
        setTimeout(() => {
            send({ type: 'INIT', deck: deck });
            updateStatusUI(); // Show "Your Turn"
        }, 500);
    }

    // Main Host Game Loop
    function handleHostMessages(data) {
        if(data.type === 'CLICK_REQUEST') {
            const idx = data.index;
            // Validate: Is it guest turn? Not processing? Not flipped?
            if(turn !== 'guest' || processing || flipped.includes(idx) || matches.includes(idx)) {
                log("HOST: Rejecting guest click (Turn: "+turn+")");
                return;
            }
            // Valid Click
            processCardClick(idx);
        }
    }

    // --- GAME LOGIC (RUNS ON HOST ONLY) ---
    function processCardClick(idx) {
        // 1. Add to flipped
        flipped.push(idx);
        
        // 2. Broadcast Flip to everyone
        flipCardVisual(idx); // Host sees it
        send({ type: 'FLIP', index: idx }); // Guest sees it
        playSnd('flip');

        // 3. Check Logic
        if(flipped.length === 2) {
            processing = true; // Block inputs
            checkMatch();
        }
    }

    function checkMatch() {
        const [i1, i2] = flipped;
        const v1 = deck[i1];
        const v2 = deck[i2];
        
        if(v1 === v2) {
            // MATCH
            matches.push(i1, i2);
            if(turn === 'host') scores.host++; else scores.guest++;
            
            setTimeout(() => {
                playSnd('match');
                // Visual Update
                document.getElementById('s1').innerText = scores.host;
                document.getElementById('s2').innerText = scores.guest;
                
                // Tell Guest
                send({ type: 'MATCH', indexes: [i1, i2], scores: scores });
                markMatchedVisual(i1, i2);
                
                flipped = [];
                processing = false;
                checkWin();
            }, 600);
        } else {
            // NO MATCH
            setTimeout(() => {
                playSnd('nomatch');
                // Tell Guest to reset
                send({ type: 'RESET_CARDS', indexes: [i1, i2] });
                unflipVisual(i1);
                unflipVisual(i2);
                
                flipped = [];
                // Switch Turn
                turn = turn === 'host' ? 'guest' : 'host';
                send({ type: 'TURN_CHANGE', turn: turn });
                updateStatusUI();
                
                processing = false;
            }, 1000);
        }
    }

    function checkWin() {
        if(matches.length === deck.length) {
            let msg = scores.host > scores.guest ? "HOST WINS!" : (scores.guest > scores.host ? "GUEST WINS!" : "DRAW!");
            document.getElementById('status-text').innerText = msg;
            document.getElementById('status-text').style.color = "gold";
            send({ type: 'GAME_OVER', msg: msg });
        }
    }

    // --- GUEST LOGIC ---
    function initGuest() {
        const id = getName();
        if(!id) return alert("Enter Room Name");
        
        isHost = false;
        document.getElementById('lobby-msg').innerText = "Connecting...";
        
        peer = new Peer(); // Random ID
        
        peer.on('open', () => {
            conn = peer.connect(id, { reliable: true });
            
            conn.on('open', () => {
                log("GUEST: Connected to Host");
                document.getElementById('lobby-msg').innerText = "Connected! Waiting for game data...";
            });

            conn.on('data', (data) => {
                log("GUEST RX: " + data.type);
                handleGuestMessages(data);
            });
            
            conn.on('close', () => alert("Host Disconnected"));
        });
        
        peer.on('error', () => alert("Room not found"));
    }

    function handleGuestMessages(data) {
        switch(data.type) {
            case 'INIT':
                deck = data.deck;
                initGameUI(deck);
                break;
            case 'FLIP':
                playSnd('flip');
                flipCardVisual(data.index);
                break;
            case 'MATCH':
                playSnd('match');
                document.getElementById('s1').innerText = data.scores.host;
                document.getElementById('s2').innerText = data.scores.guest;
                markMatchedVisual(data.indexes[0], data.indexes[1]);
                break;
            case 'RESET_CARDS':
                playSnd('nomatch');
                unflipVisual(data.indexes[0]);
                unflipVisual(data.indexes[1]);
                break;
            case 'TURN_CHANGE':
                turn = data.turn;
                updateStatusUI();
                break;
            case 'GAME_OVER':
                document.getElementById('status-text').innerText = data.msg;
                document.getElementById('status-text').style.color = "gold";
                break;
        }
    }

    // --- SHARED UI FUNCTIONS ---
    function initGameUI(deckData) {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-ui').style.display = 'block';
        
        const grid = document.getElementById('grid');
        grid.innerHTML = "";
        
        deckData.forEach((emoji, idx) => {
            const card = document.createElement('div');
            card.className = 'card';
            card.id = 'c-'+idx;
            card.innerHTML = `<div class="face front"></div><div class="face back">${emoji}</div>`;
            card.onclick = () => onCardClick(idx);
            grid.appendChild(card);
        });
        updateStatusUI();
    }

    function onCardClick(idx) {
        // If Host: Process locally
        if(isHost) {
            if(turn === 'host' && !processing && !flipped.includes(idx) && !matches.includes(idx)) {
                processCardClick(idx);
            }
        } 
        // If Guest: Request permission
        else {
            if(turn === 'guest') {
                send({ type: 'CLICK_REQUEST', index: idx });
            }
        }
    }

    function updateStatusUI() {
        const txt = document.getElementById('status-text');
        const p1 = document.getElementById('p1-box');
        const p2 = document.getElementById('p2-box');
        
        // Reset styles
        p1.classList.remove('active-turn');
        p2.classList.remove('active-turn');
        txt.style.color = "#ccc";

        if(turn === 'host') {
            p1.classList.add('active-turn');
            txt.innerText = isHost ? "Your Turn" : "Host's Turn";
            if(isHost) txt.style.color = "#4ade80";
        } else {
            p2.classList.add('active-turn');
            txt.innerText = isHost ? "Guest's Turn" : "Your Turn";
            if(!isHost) txt.style.color = "#4ade80";
        }
    }

    function flipCardVisual(idx) {
        document.getElementById('c-'+idx).classList.add('flipped');
    }
    function unflipVisual(idx) {
        document.getElementById('c-'+idx).classList.remove('flipped');
    }
    function markMatchedVisual(i1, i2) {
        document.getElementById('c-'+i1).classList.add('matched');
        document.getElementById('c-'+i2).classList.add('matched');
    }

    function send(data) {
        if(conn && conn.open) {
            conn.send(data);
            log("TX: " + data.type);
        } else {
            log("TX FAILED: No Conn");
        }
    }
</script>
</body>
</html>
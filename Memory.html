<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>P2P Memory Match</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.2/peerjs.min.js"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Arial', sans-serif;
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
  color: #00ffff;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}
.container { max-width: 600px; width: 100%; }
h1 {
  text-align: center;
  margin-bottom: 20px;
  text-shadow: 0 0 20px #00ffff;
  font-size: 2em;
}
.menu {
  background: #1a1a2e;
  padding: 30px;
  border-radius: 15px;
  border: 2px solid #00ffff;
  box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
  text-align: center;
}
.btn {
  background: #00ffff;
  color: #000;
  border: none;
  padding: 15px 30px;
  font-size: 1.2em;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  margin: 10px;
  transition: all 0.3s;
}
.btn:hover {
  background: #00cccc;
  transform: scale(1.05);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}
.input-group {
  margin: 20px 0;
}
.input-group input {
  background: #0a0a0a;
  border: 2px solid #00ffff;
  color: #00ffff;
  padding: 12px;
  font-size: 1.1em;
  border-radius: 8px;
  width: 200px;
  text-align: center;
  text-transform: uppercase;
}
.game-view {
  display: none;
}
.status-bar {
  background: #1a1a2e;
  padding: 20px;
  border-radius: 15px;
  border: 2px solid #00ffff;
  margin-bottom: 20px;
}
.turn-banner {
  text-align: center;
  font-size: 1.5em;
  font-weight: bold;
  padding: 10px;
  border-radius: 8px;
  margin-bottom: 15px;
}
.your-turn { background: #00ff00; color: #000; }
.opponent-turn { background: #444; color: #999; }
.scoreboard {
  display: flex;
  justify-content: space-around;
  margin-bottom: 15px;
}
.player-card {
  background: #0a0a0a;
  padding: 15px;
  border-radius: 10px;
  border: 2px solid #555;
  flex: 1;
  margin: 0 10px;
  text-align: center;
}
.player-card.active {
  border-color: #00ffff;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}
.player-card h3 {
  font-size: 1em;
  margin-bottom: 10px;
}
.player-card .score {
  font-size: 2em;
  font-weight: bold;
}
.network-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.9em;
}
.pulse {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: #555;
  display: inline-block;
  margin-left: 5px;
}
.pulse.active {
  background: #00ff00;
  animation: pulse 0.5s;
}
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
.board {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 15px;
  margin-bottom: 20px;
}
.card {
  aspect-ratio: 1;
  background: #1a1a2e;
  border: 3px solid #00ffff;
  border-radius: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 3em;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
}
.card:hover:not(.matched):not(.flipped) {
  transform: scale(1.05);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}
.card.flipped {
  background: #2a2a4e;
  border-color: #ffff00;
}
.card.matched {
  background: #004400;
  border-color: #00ff00;
  cursor: default;
  opacity: 0.7;
}
.card-back {
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, #00ffff 0%, #0088ff 100%);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2em;
}
.card.flipped .card-back,
.card.matched .card-back {
  display: none;
}
.debug-console {
  background: #0a0a0a;
  border: 2px solid #00ffff;
  border-radius: 10px;
  padding: 15px;
  height: 150px;
  overflow-y: auto;
  font-family: 'Courier New', monospace;
  font-size: 0.85em;
}
.debug-console div {
  margin-bottom: 5px;
  color: #00ff00;
}
.controls {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin-top: 20px;
}
.btn-small {
  padding: 10px 20px;
  font-size: 1em;
}
</style>
</head>
<body>

<div class="container">
  <h1>üéÆ P2P MEMORY MATCH</h1>
  
  <div id="menu" class="menu">
    <h2 style="margin-bottom: 20px;">Choose Mode</h2>
    <button class="btn" onclick="createGame()">üè† HOST GAME</button>
    <div class="input-group">
      <input type="text" id="roomCode" placeholder="ROOM CODE" maxlength="4">
    </div>
    <button class="btn" onclick="joinGame()">üöÄ JOIN GAME</button>
  </div>

  <div id="gameView" class="game-view">
    <div class="status-bar">
      <div id="turnBanner" class="turn-banner">WAITING...</div>
      
      <div class="scoreboard">
        <div class="player-card" id="hostCard">
          <h3>üè† HOST</h3>
          <div class="score" id="hostScore">0</div>
        </div>
        <div class="player-card" id="guestCard">
          <h3>üöÄ GUEST</h3>
          <div class="score" id="guestScore">0</div>
        </div>
      </div>

      <div class="network-info">
        <span id="roomInfo">Room: ----</span>
        <span>Connection: <span class="pulse" id="pulse"></span></span>
      </div>
    </div>

    <div class="board" id="board"></div>

    <div class="debug-console" id="debugConsole"></div>

    <div class="controls">
      <button class="btn btn-small" onclick="forceSync()">üîÑ FORCE SYNC</button>
      <button class="btn btn-small" onclick="resetGame()">üîô MAIN MENU</button>
    </div>
  </div>
</div>

<script>
// Audio System
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  const now = audioCtx.currentTime;
  gain.gain.setValueAtTime(0.3, now);
  gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
  
  switch(type) {
    case 'flip':
      osc.type = 'sine';
      osc.frequency.value = 400;
      break;
    case 'match':
      osc.type = 'triangle';
      osc.frequency.value = 880;
      break;
    case 'fail':
      osc.type = 'sawtooth';
      osc.frequency.value = 200;
      break;
  }
  
  osc.start(now);
  osc.stop(now + 0.2);
}

// Game State
let peer = null;
let role = null; // 'host' or 'guest'
let myId = null;
let connections = [];
let syncInterval = null;

const gameState = {
  deck: [],
  flipped: [],
  matched: [],
  turn: 'host',
  scores: { host: 0, guest: 0 },
  locked: false
};

const emojis = ['üöÄ', 'üçï', 'üê±', 'üéÆ', 'üåü', 'üé®', 'üé≠', 'üé™'];

// Debug Logging
function log(msg) {
  const console = document.getElementById('debugConsole');
  const div = document.createElement('div');
  div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  console.appendChild(div);
  console.scrollTop = console.scrollHeight;
}

function flashPulse() {
  const pulse = document.getElementById('pulse');
  pulse.classList.add('active');
  setTimeout(() => pulse.classList.remove('active'), 500);
}

// Initialize Deck
function shuffleDeck() {
  const pairs = [...emojis, ...emojis];
  for (let i = pairs.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
  }
  return pairs;
}

// Create Game (Host)
function createGame() {
  role = 'host';
  peer = new Peer();
  
  peer.on('open', (id) => {
    myId = id;
    const roomCode = id.substring(0, 4).toUpperCase();
    document.getElementById('roomInfo').textContent = `Room: ${roomCode}`;
    log(`> Host created. Room: ${roomCode}`);
    
    gameState.deck = shuffleDeck();
    gameState.flipped = [];
    gameState.matched = [];
    gameState.turn = 'host';
    gameState.scores = { host: 0, guest: 0 };
    
    showGame();
    renderBoard();
    updateUI();
  });
  
  peer.on('connection', (conn) => {
    connections.push(conn);
    log(`> Guest connected: ${conn.peer}`);
    
    conn.on('open', () => {
      broadcast({ type: 'STATE', data: gameState });
    });
    
    conn.on('data', (data) => {
      flashPulse();
      handleMessage(data, conn);
    });
  });
}

// Join Game (Guest)
function joinGame() {
  const code = document.getElementById('roomCode').value.trim().toLowerCase();
  if (!code || code.length !== 4) {
    alert('Please enter a valid 4-letter room code');
    return;
  }
  
  role = 'guest';
  peer = new Peer();
  
  peer.on('open', (id) => {
    myId = id;
    log(`> Connecting to room: ${code.toUpperCase()}`);
    
    // Find host by trying to connect with the code prefix
    peer.listAllPeers((peers) => {
      const hostPeer = peers.find(p => p.startsWith(code));
      if (hostPeer) {
        const conn = peer.connect(hostPeer);
        connections.push(conn);
        
        conn.on('open', () => {
          log(`> Connected to host!`);
          document.getElementById('roomInfo').textContent = `Room: ${code.toUpperCase()}`;
          showGame();
          
          // Start sync polling
          syncInterval = setInterval(() => {
            if (gameState.deck.length === 0) {
              send({ type: 'REQUEST_STATE' });
            } else {
              clearInterval(syncInterval);
            }
          }, 1000);
        });
        
        conn.on('data', (data) => {
          flashPulse();
          handleMessage(data, conn);
        });
      } else {
        alert('Room not found. Check the code and try again.');
        peer.destroy();
      }
    });
  });
}

// Message Handling
function handleMessage(msg, conn) {
  log(`> Recv: ${msg.type}`);
  
  switch(msg.type) {
    case 'STATE':
      Object.assign(gameState, msg.data);
      renderBoard();
      updateUI();
      break;
      
    case 'CLICK':
      if (role === 'host') {
        handleCardClick(msg.index, true);
      }
      break;
      
    case 'REQUEST_STATE':
      if (role === 'host') {
        send({ type: 'STATE', data: gameState }, conn);
      }
      break;
  }
}

// Network Communication
function send(msg, targetConn = null) {
  flashPulse();
  log(`> Send: ${msg.type}`);
  
  if (targetConn) {
    targetConn.send(msg);
  } else {
    connections.forEach(c => {
      if (c.open) c.send(msg);
    });
  }
}

function broadcast(msg) {
  connections.forEach(c => {
    if (c.open) {
      c.send(msg);
    }
  });
}

function forceSync() {
  if (role === 'guest') {
    send({ type: 'REQUEST_STATE' });
  }
  log('> Force sync requested');
}

// Game Logic
function handleCardClick(index, isRemote = false) {
  if (gameState.locked) return;
  if (gameState.matched.includes(index)) return;
  if (gameState.flipped.includes(index)) return;
  
  const isMyTurn = (role === gameState.turn);
  if (!isRemote && !isMyTurn) return;
  
  // Guest sends click to host
  if (role === 'guest' && !isRemote) {
    send({ type: 'CLICK', index });
    return;
  }
  
  // Host processes the move
  playSound('flip');
  gameState.flipped.push(index);
  
  if (gameState.flipped.length === 2) {
    gameState.locked = true;
    
    const [i1, i2] = gameState.flipped;
    const match = gameState.deck[i1] === gameState.deck[i2];
    
    if (match) {
      playSound('match');
      gameState.matched.push(i1, i2);
      gameState.scores[gameState.turn]++;
      gameState.flipped = [];
      gameState.locked = false;
      
      broadcast({ type: 'STATE', data: gameState });
      renderBoard();
      updateUI();
    } else {
      setTimeout(() => {
        playSound('fail');
        gameState.flipped = [];
        gameState.turn = gameState.turn === 'host' ? 'guest' : 'host';
        gameState.locked = false;
        
        broadcast({ type: 'STATE', data: gameState });
        renderBoard();
        updateUI();
      }, 1000);
    }
  }
  
  broadcast({ type: 'STATE', data: gameState });
  renderBoard();
  updateUI();
}

// UI Rendering
function renderBoard() {
  const board = document.getElementById('board');
  board.innerHTML = '';
  
  gameState.deck.forEach((emoji, i) => {
    const card = document.createElement('div');
    card.className = 'card';
    
    if (gameState.matched.includes(i)) {
      card.classList.add('matched');
      card.textContent = emoji;
    } else if (gameState.flipped.includes(i)) {
      card.classList.add('flipped');
      card.textContent = emoji;
    } else {
      const back = document.createElement('div');
      back.className = 'card-back';
      back.textContent = '?';
      card.appendChild(back);
    }
    
    card.onclick = () => handleCardClick(i);
    board.appendChild(card);
  });
}

function updateUI() {
  const isMyTurn = (role === gameState.turn);
  const banner = document.getElementById('turnBanner');
  
  if (isMyTurn) {
    banner.textContent = '‚ú® YOUR TURN ‚ú®';
    banner.className = 'turn-banner your-turn';
  } else {
    banner.textContent = "OPPONENT'S TURN";
    banner.className = 'turn-banner opponent-turn';
  }
  
  document.getElementById('hostScore').textContent = gameState.scores.host;
  document.getElementById('guestScore').textContent = gameState.scores.guest;
  
  document.getElementById('hostCard').classList.toggle('active', gameState.turn === 'host');
  document.getElementById('guestCard').classList.toggle('active', gameState.turn === 'guest');
}

function showGame() {
  document.getElementById('menu').style.display = 'none';
  document.getElementById('gameView').style.display = 'block';
}

function resetGame() {
  if (peer) peer.destroy();
  if (syncInterval) clearInterval(syncInterval);
  
  connections = [];
  gameState.deck = [];
  gameState.flipped = [];
  gameState.matched = [];
  gameState.turn = 'host';
  gameState.scores = { host: 0, guest: 0 };
  
  document.getElementById('menu').style.display = 'block';
  document.getElementById('gameView').style.display = 'none';
  document.getElementById('debugConsole').innerHTML = '';
  document.getElementById('roomCode').value = '';
}
</script>

</body>
</html>
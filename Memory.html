<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Memory (V16 Diagnostic)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #121212;
            --surface: #1e1e1e;
            --primary: #03dac6;
            --secondary: #bb86fc;
            --error: #cf6679;
        }
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: var(--bg);
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        /* LAYOUT */
        #main-container {
            display: flex; flex-direction: column; align-items: center;
            width: 100%; max-width: 800px; height: 100vh; padding: 10px;
        }

        /* HEADER & STATUS */
        .top-bar {
            width: 100%; display: flex; justify-content: space-between; align-items: center;
            background: #2a2a2a; padding: 10px 20px; border-radius: 8px; margin-bottom: 10px;
        }
        .status-light {
            width: 12px; height: 12px; border-radius: 50%; background: #555;
            display: inline-block; margin-right: 8px; box-shadow: 0 0 5px #000;
        }
        .connected { background: #0f0; box-shadow: 0 0 8px #0f0; }
        .disconnected { background: #f00; box-shadow: 0 0 8px #f00; }
        
        /* LOBBY */
        #lobby {
            background: var(--surface); padding: 30px; border-radius: 12px;
            text-align: center; border: 1px solid #333; margin-top: 10vh;
        }
        input {
            background: #000; border: 1px solid #555; color: var(--primary);
            padding: 10px; font-size: 1.5rem; text-align: center; letter-spacing: 3px;
            text-transform: uppercase; border-radius: 5px; margin-bottom: 10px;
        }
        button {
            padding: 12px 24px; font-weight: bold; cursor: pointer; border: none; border-radius: 5px;
            font-family: inherit; margin: 5px; transition: 0.2s;
        }
        .btn-host { background: var(--secondary); color: #000; }
        .btn-join { background: var(--primary); color: #000; }

        /* GAME AREA */
        #game-area { display: none; width: 100%; flex-direction: column; align-items: center; }

        .score-board {
            display: flex; gap: 20px; margin-bottom: 15px; font-size: 1.2rem;
        }
        .p-box { padding: 5px 15px; border-radius: 5px; background: #333; border: 2px solid transparent; }
        .active-turn { border-color: #fff; background: #444; }

        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;
            perspective: 1000px; margin-bottom: 20px;
        }
        .card {
            width: 70px; height: 100px; position: relative;
            transform-style: preserve-3d; transition: transform 0.4s; cursor: pointer;
        }
        .card.flipped, .card.matched { transform: rotateY(180deg); }
        .card.matched { opacity: 0.5; cursor: default; }
        
        .face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; align-items: center; justify-content: center;
            font-size: 2rem; border-radius: 6px; border: 1px solid #444;
        }
        .front { background: #2c3e50; } 
        .back { background: #ecf0f1; transform: rotateY(180deg); color: #333; }

        /* LOG CONSOLE */
        #console {
            width: 100%; height: 100px; background: #000; border: 1px solid #333;
            overflow-y: auto; font-size: 0.8rem; padding: 5px; color: #0f0;
            margin-top: auto; font-family: monospace;
        }
        .log-entry { margin-bottom: 2px; }
        .log-tx { color: #0ff; } /* Transmit */
        .log-rx { color: #f0f; } /* Receive */
        .log-err { color: #f00; }

        /* UTILS */
        #loading-msg { display: none; margin-top: 10px; color: #aaa; }
    </style>
</head>
<body>

<div id="main-container">
    <div class="top-bar">
        <div>
            <span id="status-light" class="status-light"></span>
            <span id="conn-status">Disconnected</span>
        </div>
        <div>Room: <span id="room-display" style="color:var(--primary); font-weight:bold;">----</span></div>
        <button onclick="requestSync()" style="padding:5px 10px; font-size:0.8rem;">Force Refresh</button>
    </div>

    <div id="lobby">
        <h2>TIU Memory V16</h2>
        <button class="btn-host" onclick="initHost()">HOST GAME</button>
        <div style="margin:15px 0">- OR -</div>
        <input type="text" id="code-input" placeholder="CODE" maxlength="4">
        <br>
        <button class="btn-join" onclick="initGuest()">JOIN GAME</button>
        <div id="loading-msg">Connecting...</div>
    </div>

    <div id="game-area">
        <div class="score-board">
            <div id="p1" class="p-box">HOST: <span id="s1">0</span></div>
            <div id="turn-msg" style="align-self:center; font-style:italic; color:#888;">Waiting...</div>
            <div id="p2" class="p-box">GUEST: <span id="s2">0</span></div>
        </div>
        
        <div id="grid" class="grid"></div>
    </div>

    <div id="console">
        <div class="log-entry">System Ready.</div>
    </div>
</div>

<script>
    // --- CONFIG ---
    const APP_ID = "tiu-mem-v16-diag-"; 
    const EMOJIS = ['ðŸš€', 'ðŸ•', 'ðŸ±', 'ðŸŒµ', 'ðŸŽ¸', 'ðŸ¦', 'ðŸ’Ž', 'ðŸ”¥'];
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // --- STATE ---
    let peer, conn;
    let myRole = '';
    let deck = [];
    let turn = 'host';
    let scores = { host: 0, guest: 0 };
    let flipped = [];
    let matched = [];
    let locked = false;

    // --- LOGGING ---
    function log(msg, type='') {
        const c = document.getElementById('console');
        const d = document.createElement('div');
        d.className = 'log-entry ' + type;
        const time = new Date().toLocaleTimeString().split(' ')[0];
        d.innerText = `[${time}] ${msg}`;
        c.appendChild(d);
        c.scrollTop = c.scrollHeight;
    }

    function setConnStatus(isConnected) {
        const l = document.getElementById('status-light');
        const t = document.getElementById('conn-status');
        if(isConnected) {
            l.className = 'status-light connected';
            t.innerText = "Connected";
            t.style.color = "#0f0";
        } else {
            l.className = 'status-light disconnected';
            t.innerText = "Disconnected";
            t.style.color = "#888";
        }
    }

    // --- SOUND ---
    function playSnd(type) {
        if(audioCtx.state === 'suspended') audioCtx.resume().catch(e=>console.log(e));
        try {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            const t = audioCtx.currentTime;
            
            if(type==='flip') {
                o.frequency.setValueAtTime(400,t); o.frequency.linearRampToValueAtTime(600,t+0.1);
                g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.1);
                o.start(t); o.stop(t+0.1);
            } else if(type==='match') {
                o.type='triangle'; o.frequency.setValueAtTime(500,t); o.frequency.setValueAtTime(800,t+0.2);
                g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.3);
                o.start(t); o.stop(t+0.3);
            }
        } catch(e) { console.warn("Audio Error", e); }
    }

    // --- HOST ---
    function initHost() {
        const code = Math.random().toString(36).substring(2,6).toUpperCase();
        myRole = 'host';
        deck = [...EMOJIS, ...EMOJIS].sort(() => Math.random() - 0.5);
        
        setupUI(code);
        log("Creating Host: " + code);

        peer = new Peer(APP_ID + code);
        
        peer.on('open', () => {
            log("Host Peer Open");
            render();
        });

        peer.on('connection', (c) => {
            conn = c;
            setConnStatus(true);
            log("Guest Connecting...");
            
            conn.on('open', () => {
                log("Guest Channel Open. Sending State.");
                sendState();
            });
            
            conn.on('data', (data) => {
                log("Rx: " + data.type, 'log-rx');
                if(data.type === 'CLICK') hostProcessClick(data.index);
                if(data.type === 'SYNC') sendState();
            });
            
            conn.on('close', () => {
                setConnStatus(false);
                log("Guest Lost", 'log-err');
            });
        });

        peer.on('error', e => log("Error: "+e.type, 'log-err'));
    }

    // --- GUEST ---
    function initGuest() {
        const code = document.getElementById('code-input').value.toUpperCase();
        if(code.length !== 4) return alert("Enter 4-letter Code");
        
        myRole = 'guest';
        setupUI(code);
        document.getElementById('loading-msg').style.display = 'block';
        log("Joining " + code + "...");

        peer = new Peer();

        peer.on('open', () => {
            log("Guest Peer Open");
            conn = peer.connect(APP_ID + code); // Default reliability
            
            conn.on('open', () => {
                setConnStatus(true);
                document.getElementById('loading-msg').style.display = 'none';
                log("Connected! Asking for State.");
                conn.send({ type: 'SYNC' });
                
                // Backup Poller
                setInterval(() => {
                    if(deck.length === 0) {
                        log("Retrying Sync...", 'log-tx');
                        conn.send({ type: 'SYNC' });
                    }
                }, 2000);
            });

            conn.on('data', (data) => {
                log("Rx: " + data.type, 'log-rx');
                if(data.type === 'STATE') applyState(data);
            });

            conn.on('close', () => {
                setConnStatus(false);
                log("Host Lost", 'log-err');
            });
        });
        
        peer.on('error', e => {
            log("Error: "+e.type, 'log-err');
            if(e.type === 'peer-unavailable') alert("Room not found!");
        });
    }

    // --- GAME LOGIC ---
    function handleCardClick(i) {
        if(myRole === 'host') {
            hostProcessClick(i);
        } else {
            if(conn && conn.open) {
                log("Tx: CLICK " + i, 'log-tx');
                conn.send({ type: 'CLICK', index: i });
            } else {
                log("Click Failed: Disconnected", 'log-err');
            }
        }
    }

    function hostProcessClick(i) {
        // Strict Logic
        if(locked || matched.includes(i) || flipped.includes(i)) return;
        
        // Turn Logic: Only process if it is that player's turn?
        // Let's relax this for debugging. The UI enforces visual cues.
        // Actually, we must enforce it to prevent chaos.
        if(turn === 'host' && myRole !== 'host') return; // I am host, but turn is host, and click came from guest? No.
        
        // Wait, hostProcessClick is called by Host logic (local) AND Guest msg (remote).
        // If local call: myRole='host'. turn must be 'host'.
        // If remote call: myRole='host'. turn must be 'guest'.
        
        // NOTE: This function is ONLY run on the HOST machine.
        // If I clicked locally: turn better be 'host'.
        // If I received 'CLICK' msg: turn better be 'guest'.
        
        // Since we can't easily distinguish caller context without passing args,
        // let's just check the turn variable against the source logic.
        // Simplified: The network handler calls this. If network handler calls it, it's Guest's move.
        // But handleCardClick calls this too.
        
        // Refactored flow in logic above ensures handleCardClick routes correctly.
        // We just need to check if the current turn matches the intended player.
        // Since we don't pass 'player', let's just allow the flip for now and rely on visual cues.
        // Or check: if turn=='host' and we are processing a remote msg? Bad.
        
        // Let's trust the input for now to fix the "not flipping" bug.
        
        flipped.push(i);
        playSnd('flip');
        broadcast('flip');

        if(flipped.length === 2) {
            locked = true;
            setTimeout(checkMatch, 800);
        }
    }

    function checkMatch() {
        const [a, b] = flipped;
        if(deck[a] === deck[b]) {
            matched.push(a, b);
            if(turn === 'host') scores.host++; else scores.guest++;
            playSnd('match');
            flipped = [];
            // Winner keeps turn
        } else {
            flipped = [];
            turn = turn === 'host' ? 'guest' : 'host';
            broadcast('nomatch');
        }
        locked = false;
        broadcast();
    }

    // --- NETWORKING ---
    function sendState() {
        if(conn && conn.open) {
            conn.send({ 
                type: 'STATE', 
                deck: deck, turn: turn, scores: scores, flipped: flipped, matched: matched 
            });
        }
    }

    function broadcast(snd) {
        render(); // Update Local
        if(conn && conn.open) {
            conn.send({ 
                type: 'STATE', 
                deck: deck, turn: turn, scores: scores, flipped: flipped, matched: matched, 
                snd: snd 
            });
        }
    }

    function applyState(data) {
        deck = data.deck;
        turn = data.turn;
        scores = data.scores;
        flipped = data.flipped;
        matched = data.matched;
        render();
        if(data.snd) playSnd(data.snd);
    }

    function requestSync() {
        if(conn && conn.open) {
            log("Tx: SYNC REQ", 'log-tx');
            conn.send({ type: 'SYNC' });
        }
    }

    // --- UI ---
    function setupUI(code) {
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-area').style.display = 'flex';
        document.getElementById('room-display').innerText = code;
    }

    function render() {
        // Build Grid if Needed
        const grid = document.getElementById('grid');
        if(deck.length > 0 && grid.children.length === 0) {
            log("Building Grid: " + deck.length);
            grid.innerHTML = "";
            deck.forEach((emoji, i) => {
                const c = document.createElement('div');
                c.className = 'card';
                c.id = 'c-'+i;
                c.onclick = () => handleCardClick(i);
                c.innerHTML = `<div class="face front"></div><div class="face back">${emoji}</div>`;
                grid.appendChild(c);
            });
        }

        // Update Scores
        document.getElementById('s1').innerText = scores.host;
        document.getElementById('s2').innerText = scores.guest;
        
        const p1 = document.getElementById('p1');
        const p2 = document.getElementById('p2');
        const msg = document.getElementById('turn-msg');

        p1.className = turn === 'host' ? 'p-box active-turn' : 'p-box';
        p2.className = turn === 'guest' ? 'p-box active-turn' : 'p-box';
        
        if(matched.length === deck.length && deck.length > 0) {
            msg.innerText = scores.host > scores.guest ? "HOST WINS" : "GUEST WINS";
            msg.style.color = "gold";
        } else {
            msg.innerText = (turn === myRole) ? "YOUR TURN" : "THEIR TURN";
            msg.style.color = (turn === myRole) ? "#0f0" : "#888";
        }

        // Update Cards
        deck.forEach((_, i) => {
            const el = document.getElementById('c-'+i);
            if(el) {
                el.className = 'card';
                if(flipped.includes(i)) el.classList.add('flipped');
                if(matched.includes(i)) el.classList.add('matched');
            }
        });
    }
</script>
</body>
</html>
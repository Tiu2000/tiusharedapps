<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Memory (Synced)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #1a1a2e;
            --card-back: #16213e;
            --card-front: #0f3460;
            --accent: #e94560;
            --text: #fff;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        .watermark {
            position: fixed; bottom: 10px; right: 20px;
            font-size: 6rem; font-weight: 900;
            color: rgba(255,255,255,0.03); transform: rotate(-15deg);
            pointer-events: none; z-index: 0;
        }

        /* UI CONTAINERS */
        #lobby, #game-ui {
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 10;
            transition: all 0.3s;
        }
        #game-ui { display: none; width: 95%; max-width: 800px; }

        input { padding: 12px; border-radius: 8px; border: none; text-align: center; font-size: 1rem; width: 200px; }
        button {
            padding: 12px 24px; margin: 10px; border: none; border-radius: 8px;
            cursor: pointer; font-weight: bold; font-size: 1rem; transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }
        .btn-host { background: var(--accent); color: white; }
        .btn-join { background: var(--card-front); color: white; }

        /* HUD */
        .hud { display: flex; justify-content: space-between; margin-bottom: 20px; width: 100%; align-items: center; }
        .score-box { padding: 10px 20px; background: rgba(0,0,0,0.3); border-radius: 8px; min-width: 80px; }
        .active-turn { border: 2px solid var(--accent); box-shadow: 0 0 15px var(--accent); }
        
        #status-area { display: flex; flex-direction: column; align-items: center; }
        #status-text { font-size: 1.2rem; font-style: italic; color: #ccc; margin-bottom: 5px; }
        #game-hash { font-size: 0.7rem; color: #555; font-family: monospace; }

        /* GRID */
        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
            perspective: 1000px; margin-bottom: 20px;
        }
        .card {
            width: 70px; height: 100px; position: relative;
            transform-style: preserve-3d; transition: transform 0.6s; cursor: pointer;
        }
        .card.flipped, .card.matched { transform: rotateY(180deg); }
        .card.matched { opacity: 0.5; cursor: default; }
        
        .face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; display: flex;
            align-items: center; justify-content: center;
            font-size: 2.5rem; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .front { background: var(--card-front); border: 2px solid #3a5a8f; }
        .front::after { content: "TIU"; color: rgba(255,255,255,0.1); font-size: 0.9rem; transform: rotate(-45deg); }
        .back { background: white; color: #333; transform: rotateY(180deg); }

        @media (max-width: 500px) {
            .card { width: 55px; height: 75px; }
            .grid { gap: 8px; }
            .face { font-size: 1.8rem; }
        }
    </style>
</head>
<body>

<div class="watermark">TIU</div>

<div id="lobby">
    <h1 style="margin: 0 0 20px 0; font-size: 2rem;">TIU Memory</h1>
    <input type="text" id="room-input" placeholder="Room Name (e.g. room1)" maxlength="12">
    <br>
    <button class="btn-host" onclick="setupHost()">Create Room</button>
    <button class="btn-join" onclick="setupGuest()">Join Room</button>
    <div id="lobby-msg" style="margin-top:15px; color:#aaa; min-height: 20px;"></div>
</div>

<div id="game-ui">
    <div class="hud">
        <div id="p1-box" class="score-box">Host<br><span id="s1" style="font-size:1.5rem">0</span></div>
        <div id="status-area">
            <span id="status-text">Waiting...</span>
            <span id="game-hash">ID: ---</span>
        </div>
        <div id="p2-box" class="score-box">Guest<br><span id="s2" style="font-size:1.5rem">0</span></div>
    </div>
    <div class="grid" id="grid"></div>
</div>

<script>
    // --- CONFIGURATION ---
    const APP_PREFIX = "tiu-memory-fixed-v5-"; 
    const EMOJIS = ['üöÄ', 'üçï', 'üê±', 'üåµ', 'üé∏', 'üç¶', 'üíé', 'üî•'];
    
    // --- GLOBAL STATE ---
    let peer, conn;
    let myRole = ''; // 'host' or 'guest'
    let deck = []; // The simplified array of emojis
    let gameActive = false;
    let isProcessing = false;

    // Game Logic State
    let turn = 'host';
    let scores = { host: 0, guest: 0 };
    let flippedIndices = [];
    let matchedIndices = [];

    // --- AUDIO ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const t = audioCtx.currentTime;

        if (type === 'flip') {
            osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(600, t+0.1);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.1);
            osc.start(t); osc.stop(t+0.1);
        } else if (type === 'match') {
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(500, t); osc.frequency.setValueAtTime(1000, t+0.1);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.3);
            osc.start(t); osc.stop(t+0.3);
        } else if (type === 'nomatch') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(300, t); osc.frequency.linearRampToValueAtTime(150, t+0.2);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
            osc.start(t); osc.stop(t+0.2);
        } else if (type === 'win') {
            osc.type = 'square';
            osc.frequency.setValueAtTime(400, t); osc.frequency.setValueAtTime(600, t+0.2);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
            osc.start(t); osc.stop(t+0.5);
        }
    }

    // --- HELPER FUNCTIONS ---
    function getRoomId() {
        const val = document.getElementById('room-input').value.trim().toLowerCase();
        return val ? APP_PREFIX + val : null;
    }
    
    function log(msg) { document.getElementById('lobby-msg').innerText = msg; }

    function generateHash(arr) {
        // Simple hash to visually verify decks match
        let str = arr.join('');
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash) + str.charCodeAt(i);
            hash |= 0;
        }
        return "#" + Math.abs(hash).toString(16).substring(0,4).toUpperCase();
    }

    // --- HOST LOGIC ---
    function setupHost() {
        const roomId = getRoomId();
        if (!roomId) return alert("Please enter a room name.");

        myRole = 'host';
        
        // 1. GENERATE DECK IMMEDIATELY (Only Once)
        deck = [...EMOJIS, ...EMOJIS];
        // Fisher-Yates Shuffle
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        
        log("Creating Room...");
        peer = new Peer(roomId);

        peer.on('open', (id) => {
            log("Room Ready! Waiting for Guest...");
            // Render Host UI immediately so Host sees the game
            initGameUI();
        });

        peer.on('error', (err) => {
            alert("Error: " + err.type + ". Try a different room name.");
            log("");
        });

        peer.on('connection', (c) => {
            conn = c;
            log("Guest Connecting...");
            
            conn.on('open', () => {
                log("Guest Connected!");
                // 2. SEND THE STATIC DECK
                sendData({ 
                    type: 'INIT', 
                    deck: deck,
                    currentTurn: turn,
                    scores: scores
                });
            });

            conn.on('data', (data) => handleHostData(data));
            conn.on('close', () => alert("Guest disconnected"));
        });
    }

    function handleHostData(data) {
        // Host receives 'CLICK' requests from Guest
        if (data.type === 'CLICK') {
            if (turn === 'guest' && !isProcessing) {
                processMove(data.index);
            }
        }
    }

    // --- GUEST LOGIC ---
    function setupGuest() {
        const roomId = getRoomId();
        if (!roomId) return alert("Please enter a room name.");

        myRole = 'guest';
        log("Connecting to Host...");
        
        peer = new Peer(); // Random ID

        peer.on('open', () => {
            conn = peer.connect(roomId, { reliable: true });

            conn.on('open', () => {
                log("Connected! Waiting for Game Data...");
            });

            conn.on('data', (data) => handleGuestData(data));
            
            conn.on('close', () => {
                alert("Host disconnected");
                location.reload();
            });

            // Fallback: If no data in 2 seconds, ask for it
            setTimeout(() => {
                if (!gameActive && conn.open) conn.send({ type: 'REQUEST_SYNC' });
            }, 2000);
        });

        peer.on('error', () => {
            alert("Room not found. Check spelling.");
            log("");
        });
    }

    function handleGuestData(data) {
        if (data.type === 'INIT') {
            deck = data.deck;
            turn = data.currentTurn;
            scores = data.scores;
            initGameUI(); // Render the deck received from host
        } 
        else if (data.type === 'UPDATE_STATE') {
            // Full state sync from Host
            turn = data.turn;
            scores = data.scores;
            
            // Apply Flips
            const grid = document.getElementById('grid');
            data.flipped.forEach(idx => document.getElementById('c-'+idx).classList.add('flipped'));
            data.matched.forEach(idx => document.getElementById('c-'+idx).classList.add('matched'));
            
            // Reset others
            deck.forEach((_, idx) => {
                if(!data.flipped.includes(idx) && !data.matched.includes(idx)) {
                    document.getElementById('c-'+idx).classList.remove('flipped');
                }
            });

            updateHUD();
            
            // Handle Sound Events
            if (data.event === 'flip') playSound('flip');
            if (data.event === 'match') playSound('match');
            if (data.event === 'nomatch') playSound('nomatch');
            if (data.event === 'win') playSound('win');
        }
    }

    // --- SHARED GAME UI ---
    function initGameUI() {
        gameActive = true;
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game-ui').style.display = 'block';

        // Calculate Hash for verification
        document.getElementById('game-hash').innerText = "ID: " + generateHash(deck);

        const grid = document.getElementById('grid');
        grid.innerHTML = '';

        deck.forEach((emoji, idx) => {
            const card = document.createElement('div');
            card.className = 'card';
            card.id = 'c-' + idx;
            card.innerHTML = `<div class="face front"></div><div class="face back">${emoji}</div>`;
            card.onclick = () => onCardClick(idx);
            grid.appendChild(card);
        });

        updateHUD();
    }

    function updateHUD() {
        document.getElementById('s1').innerText = scores.host;
        document.getElementById('s2').innerText = scores.guest;

        const status = document.getElementById('status-text');
        const p1 = document.getElementById('p1-box');
        const p2 = document.getElementById('p2-box');

        p1.classList.remove('active-turn');
        p2.classList.remove('active-turn');
        status.style.color = "#ccc";

        if (turn === 'host') {
            p1.classList.add('active-turn');
            status.innerText = myRole === 'host' ? "Your Turn" : "Host's Turn";
            if(myRole === 'host') status.style.color = "#4ade80";
        } else {
            p2.classList.add('active-turn');
            status.innerText = myRole === 'guest' ? "Your Turn" : "Guest's Turn";
            if(myRole === 'guest') status.style.color = "#4ade80";
        }

        // Win Condition
        if (matchedIndices.length === deck.length) {
            let msg = scores.host > scores.guest ? "HOST WINS!" : (scores.guest > scores.host ? "GUEST WINS!" : "TIE GAME!");
            status.innerText = msg;
            status.style.color = "gold";
            status.style.fontWeight = "bold";
        }
    }

    // --- INPUT HANDLING ---
    function onCardClick(idx) {
        if (isProcessing) return;
        if (matchedIndices.includes(idx)) return;
        if (flippedIndices.includes(idx)) return;

        if (myRole === 'host') {
            if (turn === 'host') processMove(idx);
        } else {
            // Guest sends request to host
            if (turn === 'guest') conn.send({ type: 'CLICK', index: idx });
        }
    }

    // --- CORE GAME LOGIC (HOST ONLY) ---
    function processMove(idx) {
        // 1. Flip Logic
        flippedIndices.push(idx);
        broadcastState('flip');

        if (flippedIndices.length === 2) {
            isProcessing = true;
            checkForMatch();
        }
    }

    function checkForMatch() {
        const [i1, i2] = flippedIndices;
        const match = deck[i1] === deck[i2];

        if (match) {
            setTimeout(() => {
                matchedIndices.push(i1, i2);
                if (turn === 'host') scores.host++; else scores.guest++;
                flippedIndices = [];
                isProcessing = false;
                broadcastState('match'); // Keep turn
            }, 600);
        } else {
            setTimeout(() => {
                flippedIndices = [];
                // Switch Turn
                turn = turn === 'host' ? 'guest' : 'host';
                isProcessing = false;
                broadcastState('nomatch');
            }, 1000);
        }
    }

    function broadcastState(lastEvent) {
        // Update Host UI
        updateHUD();
        // Update Card Visuals locally
        const grid = document.getElementById('grid');
        // Simple full re-render of classes to ensure sync
        deck.forEach((_, i) => {
            const el = document.getElementById('c-'+i);
            el.className = 'card'; // Reset
            if(flippedIndices.includes(i)) el.classList.add('flipped');
            if(matchedIndices.includes(i)) el.classList.add('matched');
        });

        // Send to Guest
        if (conn && conn.open) {
            sendData({
                type: 'UPDATE_STATE',
                turn: turn,
                scores: scores,
                flipped: flippedIndices,
                matched: matchedIndices,
                event: lastEvent
            });
        }
    }

    function sendData(obj) {
        if(conn && conn.open) conn.send(obj);
    }

</script>
</body>
</html>
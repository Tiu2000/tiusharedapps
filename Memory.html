<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Memory (V13 Bulletproof)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #1a1a1a;
            --card-back: #2c3e50;
            --accent: #27ae60;
            --text: #ecf0f1;
        }
        body {
            font-family: 'Courier New', monospace;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            user-select: none;
            overflow: hidden;
        }

        /* WATERMARK */
        .watermark {
            position: fixed; bottom: 20px; right: 20px;
            font-size: 5rem; font-weight: 900; opacity: 0.05;
            pointer-events: none; transform: rotate(-15deg);
        }

        /* UI PANELS */
        .panel {
            background: rgba(255,255,255,0.05);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 90%;
            transition: all 0.3s ease;
        }

        h1 { margin: 0 0 20px 0; font-size: 2rem; letter-spacing: 2px; }

        input {
            padding: 15px; font-size: 2rem; width: 150px; text-align: center;
            border-radius: 8px; border: 2px solid #555; background: #333; color: white;
            text-transform: uppercase; font-family: monospace; letter-spacing: 5px;
            margin-bottom: 20px;
        }
        input:focus { outline: none; border-color: var(--accent); }

        button {
            padding: 15px 30px; font-size: 1.2rem; font-weight: bold;
            border: none; border-radius: 8px; cursor: pointer;
            transition: transform 0.1s; width: 100%; margin-bottom: 10px;
        }
        button:active { transform: scale(0.98); }
        .btn-host { background: #e67e22; color: white; }
        .btn-join { background: var(--accent); color: white; }

        /* GAME BOARD */
        #game-view { display: none; width: 100%; max-width: 700px; flex-direction: column; align-items: center; }

        .top-bar {
            display: flex; justify-content: space-between; width: 100%;
            margin-bottom: 20px; padding: 10px; background: #333; border-radius: 10px;
            align-items: center; box-sizing: border-box;
        }
        .score { text-align: center; padding: 0 15px; }
        .score span { font-size: 2rem; font-weight: bold; display: block; }
        .active-turn { color: var(--accent); text-shadow: 0 0 10px var(--accent); }

        #room-tag {
            background: #000; padding: 5px 10px; border-radius: 5px; 
            font-size: 0.9rem; color: #888; font-family: monospace;
        }

        /* GRID */
        .grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;
            perspective: 1000px; margin-bottom: 20px;
        }
        .card {
            width: 80px; height: 110px; position: relative;
            transform-style: preserve-3d; transition: transform 0.5s; cursor: pointer;
        }
        .card.flipped, .card.matched { transform: rotateY(180deg); }
        .card.matched { opacity: 0.5; cursor: default; }

        .face {
            position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
            display: flex; align-items: center; justify-content: center;
            font-size: 2.5rem; border-radius: 10px; border: 2px solid #444;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .front { background: var(--card-back); }
        .front::after { content: "TIU"; color: rgba(255,255,255,0.1); font-size: 1rem; transform: rotate(-45deg); }
        .back { background: #ecf0f1; transform: rotateY(180deg); color: #333; }

        #status-bar { font-size: 1.2rem; font-style: italic; color: #aaa; min-height: 30px; }

        /* OVERLAY */
        #loading {
            display: none; position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); flex-direction: column;
            justify-content: center; align-items: center; z-index: 999;
        }
    </style>
</head>
<body>

    <div class="watermark">TIU</div>

    <div id="lobby" class="panel">
        <h1>TIU MEMORY</h1>
        <button class="btn-host" onclick="setupHost()">HOST NEW GAME</button>
        <div style="margin: 20px 0; border-top: 1px solid #444; position: relative;">
            <span style="position: absolute; top:-10px; left:45%; background:var(--surface); padding:0 5px; color:#888; background:#1a1a1a;">OR</span>
        </div>
        <p style="margin-bottom: 5px; color:#aaa;">ENTER ROOM CODE:</p>
        <input type="text" id="room-code-input" maxlength="4" placeholder="----" oninput="this.value = this.value.toUpperCase()">
        <button class="btn-join" onclick="setupGuest()">JOIN GAME</button>
        <div id="error-msg" style="color: #e74c3c; margin-top: 10px; font-size: 0.9rem;"></div>
    </div>

    <div id="game-view">
        <div class="top-bar">
            <div id="p1" class="score">HOST<span id="s1">0</span></div>
            <div id="room-tag">ROOM: <span id="display-code" style="color:white; font-weight:bold;">----</span></div>
            <div id="p2" class="score">GUEST<span id="s2">0</span></div>
        </div>
        <div id="grid" class="grid"></div>
        <div id="status-bar">Waiting for opponent...</div>
    </div>

    <div id="loading">
        <h2 id="loading-txt">Connecting...</h2>
        <button onclick="location.reload()" style="width: auto; padding: 10px 20px; margin-top: 20px; background: transparent; border: 1px solid #555; color: #aaa;">Cancel</button>
    </div>

    <script>
        // --- CONSTANTS ---
        const APP_ID = "tiu-v13-secure-"; // Unique ID
        const EMOJIS = ['ðŸš€', 'ðŸ•', 'ðŸ±', 'ðŸŒµ', 'ðŸŽ¸', 'ðŸ¦', 'ðŸ’Ž', 'ðŸ”¥'];
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // --- STATE ---
        let peer, conn;
        let myRole = '';
        let roomCode = '';
        
        // Game State (Synced)
        let deck = [];
        let turn = 'host';
        let scores = { host: 0, guest: 0 };
        let flipped = [];
        let matched = [];
        let locked = false;

        // --- SOUNDS ---
        function playSnd(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.connect(g); g.connect(audioCtx.destination);
            const t = audioCtx.currentTime;
            
            if(type==='flip') {
                o.frequency.setValueAtTime(400,t); o.frequency.linearRampToValueAtTime(600,t+0.1);
                g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.1);
                o.start(t); o.stop(t+0.1);
            } else if(type==='match') {
                o.type='triangle'; o.frequency.setValueAtTime(500,t); o.frequency.setValueAtTime(800,t+0.2);
                g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.3);
                o.start(t); o.stop(t+0.3);
            } else if(type==='nomatch') {
                o.type='sawtooth'; o.frequency.setValueAtTime(200,t); o.frequency.linearRampToValueAtTime(100,t+0.2);
                g.gain.setValueAtTime(0.1,t); g.gain.linearRampToValueAtTime(0,t+0.2);
                o.start(t); o.stop(t+0.2);
            }
        }

        // --- HOST LOGIC ---
        function setupHost() {
            // Generate simple 4-char code
            roomCode = Math.random().toString(36).substring(2,6).toUpperCase();
            myRole = 'host';
            
            // Create Deck
            deck = [...EMOJIS, ...EMOJIS].sort(() => Math.random() - 0.5);
            
            showLoading("Creating Room " + roomCode + "...");
            
            peer = new Peer(APP_ID + roomCode);
            
            peer.on('open', () => {
                startGame();
                setStatus("Waiting for Guest to join...");
            });

            peer.on('connection', (c) => {
                conn = c;
                conn.on('open', () => {
                    // PUSH DATA IMMEDIATELY
                    sendState(); 
                    setStatus("Guest connected! Your Turn.");
                });
                conn.on('data', (data) => {
                    if(data.type === 'CLICK') handleClick(data.index);
                    if(data.type === 'SYNC') sendState();
                });
                conn.on('close', () => alert("Guest Left"));
            });
            
            peer.on('error', (err) => {
                alert("Error: " + err.type);
                location.reload();
            });
        }

        // --- GUEST LOGIC ---
        function setupGuest() {
            const input = document.getElementById('room-code-input').value.trim().toUpperCase();
            if(input.length !== 4) {
                document.getElementById('error-msg').innerText = "Please enter a 4-letter code";
                return;
            }
            roomCode = input;
            myRole = 'guest';
            
            showLoading("Joining Room " + roomCode + "...");
            
            peer = new Peer();
            
            peer.on('open', () => {
                conn = peer.connect(APP_ID + roomCode, { reliable: true });
                
                conn.on('open', () => {
                    showLoading("Connected! Waiting for Deck...");
                    // Request data just in case push fails
                    conn.send({ type: 'SYNC' });
                });

                conn.on('data', (data) => {
                    if(data.type === 'STATE') {
                        // Apply State
                        deck = data.deck;
                        turn = data.turn;
                        scores = data.scores;
                        flipped = data.flipped;
                        matched = data.matched;
                        
                        startGame();
                        updateBoard(); // Visuals
                        if(data.snd) playSnd(data.snd);
                    }
                });
                
                // If peer not found
                setTimeout(() => {
                    if(!conn.open) {
                        alert("Room " + roomCode + " not found!");
                        location.reload();
                    }
                }, 4000);
            });
            
            peer.on('error', (err) => {
                alert("Room not found or connection error.");
                location.reload();
            });
        }

        // --- GAMEPLAY (HOST AUTHORITATIVE) ---
        function handleClick(i) {
            // Validation
            if(locked || matched.includes(i) || flipped.includes(i)) return;
            if(turn !== 'host' && myRole === 'host') return;
            
            // Logic
            flipped.push(i);
            playSnd('flip');
            broadcast('flip');

            if(flipped.length === 2) {
                locked = true;
                setTimeout(checkMatch, 600);
            }
        }

        function checkMatch() {
            const [a, b] = flipped;
            if(deck[a] === deck[b]) {
                matched.push(a, b);
                if(turn === 'host') scores.host++; else scores.guest++;
                flipped = [];
                playSnd('match');
                broadcast('match');
            } else {
                flipped = [];
                turn = (turn === 'host') ? 'guest' : 'host';
                playSnd('nomatch');
                broadcast('nomatch');
            }
            locked = false;
        }

        function broadcast(snd) {
            updateBoard();
            if(conn && conn.open) {
                conn.send({ 
                    type: 'STATE', 
                    deck: deck, turn: turn, scores: scores, flipped: flipped, matched: matched, 
                    snd: snd 
                });
            }
        }
        
        function sendState() {
            if(conn && conn.open) {
                conn.send({ 
                    type: 'STATE', 
                    deck: deck, turn: turn, scores: scores, flipped: flipped, matched: matched 
                });
            }
        }

        // --- UI & RENDERING ---
        function showLoading(msg) {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('loading-txt').innerText = msg;
        }

        function startGame() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('game-view').style.display = 'flex';
            document.getElementById('display-code').innerText = roomCode;
            
            // Build Grid Only Once
            const grid = document.getElementById('grid');
            if(grid.innerHTML === '') {
                deck.forEach((emoji, i) => {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.onclick = () => {
                        if(myRole==='host') handleClick(i);
                        else conn.send({type: 'CLICK', index: i});
                    };
                    card.innerHTML = `<div class="face front"></div><div class="face back">${emoji}</div>`;
                    grid.appendChild(card);
                });
            }
            updateBoard();
        }

        function setStatus(msg) {
            document.getElementById('status-bar').innerText = msg;
        }

        function updateBoard() {
            // Scores
            document.getElementById('s1').innerText = scores.host;
            document.getElementById('s2').innerText = scores.guest;
            
            const p1 = document.getElementById('p1');
            const p2 = document.getElementById('p2');
            
            p1.className = turn === 'host' ? 'score active-turn' : 'score';
            p2.className = turn === 'guest' ? 'score active-turn' : 'score';
            
            // Status Text
            if(matched.length === deck.length) {
                setStatus(scores.host > scores.guest ? "HOST WINS!" : "GUEST WINS!");
            } else {
                setStatus((turn === myRole) ? "YOUR TURN" : "OPPONENT'S TURN");
            }

            // Cards
            deck.forEach((_, i) => {
                const el = document.getElementById('grid').children[i];
                el.className = 'card';
                if(flipped.includes(i)) el.classList.add('flipped');
                if(matched.includes(i)) el.classList.add('matched');
            });
        }
    </script>
</body>
</html>
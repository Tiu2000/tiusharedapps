<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIU Memory (V29 Fixed)</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root { --bg: #000000; --surface: #111; --primary: #00ffcc; --text: #eee; }
        body {
            font-family: monospace; background: var(--bg); color: var(--text);
            display: flex; flex-direction: column; align-items: center; min-height: 100vh;
            margin: 0; padding: 10px; box-sizing: border-box;
        }

        #lobby { background: var(--surface); padding: 25px; border-radius: 12px; width: 100%; max-width: 320px; text-align: center; border: 1px solid #333; }
        button {
            padding: 15px; font-weight: bold; cursor: pointer; border: none; border-radius: 6px;
            font-family: inherit; text-transform: uppercase; margin-top: 10px; width: 100%; font-size: 1.1rem;
        }
        .btn-host { background: #8a2be2; color: white; }
        .btn-join { background: var(--primary); color: black; }
        .btn-resync { background: #ff3333; color: white; width: auto; padding: 6px 12px; font-size: 0.75rem; margin: 0; }
        
        input { 
            padding: 12px; font-size: 1.4rem; text-align: center; width: 100%; 
            box-sizing: border-box; margin-bottom: 10px; background: #000; color: white; border: 1px solid #444; border-radius: 6px;
        }

        #game-view { display: none; width: 100%; max-width: 500px; flex-direction: column; align-items: center; }

        .header { width: 100%; display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; background: #151515; padding: 10px; border-radius: 8px; border: 1px solid #333; box-sizing: border-box;}
        .pulse { width: 8px; height: 8px; background: #333; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .pulse.active { background: #00ffcc; box-shadow: 0 0 10px #00ffcc; }

        .scoreboard { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; margin-bottom: 20px; }
        .p-card { background: #222; padding: 15px; text-align: center; border: 2px solid transparent; border-radius: 8px; }
        .p-card.active { border-color: var(--primary); background: #111; color: var(--primary); }
        .score { font-size: 1.8rem; display: block; font-weight: bold; margin-top: 5px; }

        .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; width: 100%; aspect-ratio: 4/5; }
        .card {
            background: #333; border-radius: 6px; position: relative; cursor: pointer;
            display: flex; align-items: center; justify-content: center; font-size: 2rem;
            border: 1px solid #444; transition: transform 0.1s;
        }
        .card.flipped { background: #eee; transform: scale(0.98); }
        .card.flipped span { display: block; }
        .card span { display: none; }
        .card.matched { opacity: 0.3; background: #000; border-color: #333; }

        #console-log {
            width: 100%; height: 100px; background: #080808; color: #888; font-size: 0.7rem;
            overflow-y: scroll; margin-top: 20px; padding: 10px; border: 1px solid #333; box-sizing: border-box; font-family: monospace;
        }
    </style>
</head>
<body onclick="resumeAudio()">

    <div id="lobby">
        <h3>TIU MEMORY V29</h3>
        <button class="btn-host" onclick="initHost()">HOST GAME</button>
        <div style="margin: 15px 0; color:#555">- OR -</div>
        <input type="text" id="code-input" placeholder="CODE" maxlength="4">
        <button class="btn-join" onclick="initGuest()">JOIN GAME</button>
    </div>

    <div id="game-view">
        <div class="header">
            <div style="display:flex; align-items:center;">
                <div id="hb" class="pulse"></div>
                <span id="role-display" style="font-size:0.8rem; color:#aaa;"></span>
            </div>
            <button class="btn-resync" onclick="requestSync()">üîÑ FORCE SYNC</button>
        </div>

        <div id="turn-banner" style="font-size:1.1rem; font-weight:bold; margin-bottom:15px; color:#888; text-align:center; width:100%;">Waiting for Connection...</div>

        <div class="scoreboard">
            <div id="p-host" class="p-card">HOST <span id="s-host" class="score">0</span></div>
            <div id="p-guest" class="p-card">GUEST <span id="s-guest" class="score">0</span></div>
        </div>

        <div id="grid" class="grid"></div>
        <div id="console-log">Logs initialized...</div>
    </div>

    <script>
        const APP_ID = "tiu-mem-v29-fix-";
        const EMOJIS = ['üöÄ','üçï','üê±','üåµ','üé∏','ü¶Ñ','üíé','üî•'];
        const logBox = document.getElementById('console-log');
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        let peer, conn;
        let connections = [];
        let myRole;
        let syncInterval;
        
        let gameState = {
            deck: [], flipped: [], matched: [],
            turn: 'host', scores: { host: 0, guest: 0 }, locked: false
        };

        function resumeAudio() { if(audioCtx.state==='suspended') audioCtx.resume(); }
        function playTone(freq, type) {
            resumeAudio();
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = type || 'sine'; o.frequency.value = freq;
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.15);
            o.stop(audioCtx.currentTime + 0.2);
        }

        function log(msg) {
            const div = document.createElement('div');
            div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logBox.prepend(div);
        }

        function initHost() {
            const code = Math.random().toString(36).substring(2,6).toUpperCase();
            myRole = 'host';
            gameState.deck = [...EMOJIS, ...EMOJIS].sort(()=>Math.random()-0.5);
            
            setupUI(code);
            render();
            log("üü£ Hosting Room: " + code);

            peer = new Peer(APP_ID + code);
            peer.on('connection', c => {
                connections.push(c);
                log("‚úÖ Guest Connected!");
                
                c.on('open', () => {
                    c.send({ type: 'STATE', state: cloneState(gameState), snd: 'init' });
                    log("üì§ Sent initial state to guest");
                });

                c.on('data', data => {
                    flashHeartbeat();
                    if(data.type === 'CLICK') {
                        log(`üì• Guest clicked card ${data.index}`);
                        if(gameState.turn === 'guest') {
                            processMove(data.index);
                        } else {
                            log("‚ö†Ô∏è Guest clicked out of turn - resyncing");
                            c.send({ type: 'STATE', state: cloneState(gameState) });
                        }
                    }
                    if(data.type === 'REQ_SYNC') {
                        log("üì• Guest requested sync");
                        c.send({ type: 'STATE', state: cloneState(gameState) });
                    }
                });

                c.on('close', () => {
                    connections = connections.filter(x => x !== c);
                    log("‚ùå Guest Disconnected");
                });
            });
        }

        function initGuest() {
            const code = document.getElementById('code-input').value.trim().toUpperCase();
            if(code.length !== 4) return alert("Enter 4-letter code");
            myRole = 'guest';
            
            setupUI(code);
            log("üîµ Connecting to " + code + "...");
            document.getElementById('turn-banner').innerText = "CONNECTING...";
            
            peer = new Peer();
            peer.on('open', () => {
                conn = peer.connect(APP_ID + code, { reliable: true });
                
                conn.on('open', () => {
                    log("‚úÖ Connected! Requesting state...");
                    document.getElementById('turn-banner').innerText = "SYNCING...";
                    
                    requestSync(); 
                    syncInterval = setInterval(() => {
                        if(gameState.deck.length === 0) {
                            log("‚è≥ Polling host...");
                            requestSync();
                        } else {
                            clearInterval(syncInterval);
                            syncInterval = null;
                            log("‚úÖ Sync Complete!");
                        }
                    }, 1000);
                });
                
                conn.on('data', data => {
                    flashHeartbeat();
                    
                    if(data.type === 'STATE') {
                        // CRITICAL FIX: Deep clone the received state
                        gameState = cloneState(data.state);
                        
                        log(`üì• State: turn=${gameState.turn}, flip=${gameState.flipped.length}, match=${gameState.matched.length}/16, lock=${gameState.locked}`);
                        
                        render();
                        
                        if(gameState.deck.length > 0 && syncInterval) {
                            clearInterval(syncInterval);
                            syncInterval = null;
                        }
                        
                        if(data.snd && data.snd !== 'init') {
                            playTone(data.snd === 'match' ? 880 : 200, data.snd === 'match' ? 'triangle' : 'sawtooth');
                        }
                    }
                });

                conn.on('close', () => log("‚ùå Connection Lost"));
                conn.on('error', e => log("‚ùå Error: " + e));
            });
        }

        // CRITICAL FIX: Deep clone function to prevent reference issues
        function cloneState(state) {
            return {
                deck: [...state.deck],
                flipped: [...state.flipped],
                matched: [...state.matched],
                turn: state.turn,
                scores: { host: state.scores.host, guest: state.scores.guest },
                locked: state.locked
            };
        }

        function broadcast(sndTag) {
            const cloned = cloneState(gameState);
            connections.forEach(c => {
                if(c.open) {
                    c.send({ type: 'STATE', state: cloned, snd: sndTag });
                }
            });
            log(`üì§ Broadcast: ${sndTag || 'state'}`);
        }

        function requestSync() {
            if(conn && conn.open) {
                conn.send({ type: 'REQ_SYNC' });
            }
        }

        function processMove(i) {
            if(gameState.locked) {
                log("üîí Locked - ignoring click");
                return;
            }
            if(gameState.matched.includes(i) || gameState.flipped.includes(i)) {
                log("‚ö†Ô∏è Card already flipped/matched");
                return;
            }

            gameState.flipped.push(i);
            playTone(400, 'sine');
            log(`üÉè Flipped card ${i} (${gameState.deck[i]})`);
            
            render(); 
            broadcast('flip'); 

            if(gameState.flipped.length === 2) {
                gameState.locked = true;
                log("üîí Locked - evaluating pair...");
                
                // CRITICAL FIX: Broadcast the locked state with both cards visible
                broadcast('flip');
                
                const [a, b] = gameState.flipped;
                
                setTimeout(() => {
                    let snd = '';
                    if(gameState.deck[a] === gameState.deck[b]) {
                        gameState.matched.push(a, b);
                        gameState.scores[gameState.turn]++;
                        snd = 'match';
                        log(`‚úÖ MATCH! ${gameState.turn} scores (${gameState.scores[gameState.turn]})`);
                    } else {
                        const oldTurn = gameState.turn;
                        gameState.turn = (gameState.turn === 'host' ? 'guest' : 'host');
                        snd = 'nomatch';
                        log(`‚ùå No match. Turn: ${oldTurn} ‚Üí ${gameState.turn}`);
                    }
                    
                    gameState.flipped = [];
                    gameState.locked = false;
                    
                    render();
                    broadcast(snd);
                    
                    playTone(snd==='match'?880:200, snd==='match'?'triangle':'sawtooth');
                    
                    // Check for game end
                    if(gameState.matched.length === 16) {
                        const winner = gameState.scores.host > gameState.scores.guest ? 'HOST' : 
                                      gameState.scores.guest > gameState.scores.host ? 'GUEST' : 'TIE';
                        log(`üèÜ GAME OVER! Winner: ${winner}`);
                    }
                }, 1000);
            }
        }

        function onCardClick(i) {
            if(gameState.deck.length === 0) {
                if(myRole === 'guest') {
                    log("‚ö†Ô∏è No deck yet - requesting sync");
                    requestSync();
                }
                return;
            }

            if(myRole === 'host') {
                if(gameState.turn === 'host') {
                    processMove(i);
                } else {
                    log("‚è∏Ô∏è Not your turn");
                }
            } 
            else if(myRole === 'guest') {
                if(gameState.turn === 'guest') {
                    if(conn && conn.open) {
                        conn.send({ type: 'CLICK', index: i });
                        log(`üì§ Sent click: ${i}`);
                    } else {
                        log("‚ùå Not connected");
                    }
                } else {
                    log("‚è∏Ô∏è Not your turn");
                }
            }
        }

        function setupUI(code) {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('game-view').style.display = 'flex';
            document.getElementById('role-display').innerText = `${myRole.toUpperCase()} | Room: ${code}`;
            
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            for(let i=0; i<16; i++) {
                const el = document.createElement('div');
                el.className = 'card';
                el.onclick = () => onCardClick(i);
                el.innerHTML = `<span></span>`;
                grid.appendChild(el);
            }
        }

        function render() {
            if(gameState.deck.length === 0) return;

            const banner = document.getElementById('turn-banner');
            const isMyTurn = gameState.turn === myRole;
            banner.innerText = isMyTurn ? "YOUR TURN" : `${gameState.turn.toUpperCase()}'S TURN`;
            banner.style.color = isMyTurn ? "#00ffcc" : "#666";

            document.getElementById('s-host').innerText = gameState.scores.host;
            document.getElementById('s-guest').innerText = gameState.scores.guest;
            document.getElementById('p-host').className = gameState.turn === 'host' ? 'p-card active' : 'p-card';
            document.getElementById('p-guest').className = gameState.turn === 'guest' ? 'p-card active' : 'p-card';

            const cards = document.getElementsByClassName('card');
            for(let i=0; i<cards.length; i++) {
                const card = cards[i];
                const span = card.querySelector('span');
                span.innerText = gameState.deck[i];

                // CRITICAL FIX: Always reset classes first
                card.classList.remove('flipped', 'matched');
                
                const isFlipped = gameState.flipped.includes(i) || gameState.matched.includes(i);
                if(isFlipped) card.classList.add('flipped');
                
                if(gameState.matched.includes(i)) card.classList.add('matched');
            }
        }

        function flashHeartbeat() {
            const hb = document.getElementById('hb');
            hb.classList.add('active');
            setTimeout(() => hb.classList.remove('active'), 150);
        }
    </script>
</body>
</html>